1
00:00:00,860 --> 00:00:02,180
好 在这一张开始之前呢

2
00:00:02,180 --> 00:00:03,419
我们要先科普一个事情

3
00:00:03,419 --> 00:00:04,339
就是算法复杂度

4
00:00:04,339 --> 00:00:06,219
因为这个事情非常非常重要

5
00:00:06,219 --> 00:00:08,019
所以说我们必须要先科普一下

6
00:00:08,019 --> 00:00:09,740
我们会讲到什么是复杂度

7
00:00:09,740 --> 00:00:11,980
以及时间复杂度和空间复杂度

8
00:00:11,980 --> 00:00:13,580
只要把这三个搞明白了

9
00:00:13,580 --> 00:00:16,000
然后我们这一张再讲其他的问题呢

10
00:00:16,000 --> 00:00:17,879
那你大概就能明白了很多

11
00:00:17,879 --> 00:00:19,900
如果说这三个都没搞明白

12
00:00:19,900 --> 00:00:21,500
那然后去做算法题

13
00:00:21,500 --> 00:00:23,420
那有些地方你是含糊的

14
00:00:23,420 --> 00:00:24,539
或者说你是抓不到重点的

15
00:00:24,539 --> 00:00:26,260
所以说我们再来强调一下

16
00:00:26,260 --> 00:00:28,620
学算法 学术语结构

17
00:00:28,620 --> 00:00:30,220
大家觉得最重要的是什么

18
00:00:30,220 --> 00:00:31,400
是刷题吗

19
00:00:31,400 --> 00:00:33,539
是我们去那个LITCO的网站去刷题吗

20
00:00:33,539 --> 00:00:36,140
不是的 是要先学基本功

21
00:00:36,140 --> 00:00:38,219
算法的基本功就是复杂度

22
00:00:38,219 --> 00:00:39,460
那对于数据结构呢

23
00:00:39,460 --> 00:00:40,679
就是各个常用的数据结构

24
00:00:40,679 --> 00:00:42,500
那我们后面会逐步的去讲

25
00:00:42,500 --> 00:00:44,280
我们先把这个算法复杂度

26
00:00:44,280 --> 00:00:45,179
再给讲出来

27
00:00:45,179 --> 00:00:46,740
这会儿呢还是比较麻烦的

28
00:00:46,740 --> 00:00:49,000
我会尽量的用比较通俗一动的语言

29
00:00:49,000 --> 00:00:49,620
给大家讲明白

30
00:00:49,620 --> 00:00:50,640
注意事项

31
00:00:50,640 --> 00:00:52,719
首先呢我们这一节是一个科普

32
00:00:52,719 --> 00:00:54,600
所以说如果是你已经熟悉的

33
00:00:54,600 --> 00:00:55,159
算法复杂度呢

34
00:00:55,159 --> 00:00:56,159
那这一节你可以忽略

35
00:00:56,159 --> 00:00:57,939
但是保证你是熟悉

36
00:00:57,939 --> 00:00:59,559
如果你不确定你是熟悉

37
00:00:59,559 --> 00:01:01,419
那你就花十分钟去看看这一节

38
00:01:01,419 --> 00:01:02,199
内容也不多

39
00:01:02,199 --> 00:01:04,819
然后算法复杂度是非常重要的

40
00:01:04,819 --> 00:01:05,640
如果不掌握

41
00:01:05,640 --> 00:01:07,299
则没有办法去学习本章

42
00:01:07,299 --> 00:01:09,840
所以说你不要着急去学习下面的内容

43
00:01:09,840 --> 00:01:10,799
先把这一节看完

44
00:01:10,799 --> 00:01:13,539
然后如果你真的是第一次接触

45
00:01:13,539 --> 00:01:15,719
或者说之前只是听说没有去了解

46
00:01:15,719 --> 00:01:16,939
第一次接触呢

47
00:01:16,939 --> 00:01:18,739
那这个概念是非常有难度的

48
00:01:18,739 --> 00:01:21,039
所以说你第一节花十分钟的时间

49
00:01:21,039 --> 00:01:22,019
你理解不了

50
00:01:22,019 --> 00:01:23,359
这个是很正常的事情

51
00:01:23,359 --> 00:01:25,239
所以说不要觉得自己是笨啊

52
00:01:25,239 --> 00:01:27,479
或者说自己不适合学习算法啊之类的

53
00:01:27,480 --> 00:01:28,260
这个都不对啊

54
00:01:28,260 --> 00:01:29,680
我当时第一次接触的时候

55
00:01:29,680 --> 00:01:31,400
上学的时候也是感觉理解不了

56
00:01:31,400 --> 00:01:32,520
这是谁想出来的东西

57
00:01:32,520 --> 00:01:33,380
这么烧闹对吧

58
00:01:33,380 --> 00:01:34,980
这可能是一帮数学家想出来的东西

59
00:01:34,980 --> 00:01:36,659
因为搞数学搞计算机的人

60
00:01:36,659 --> 00:01:37,700
脑子和正常人

61
00:01:37,700 --> 00:01:38,600
它是不太一样的

62
00:01:38,600 --> 00:01:39,000
你知道了

63
00:01:39,000 --> 00:01:41,060
所以说你理解不了怎么办呢

64
00:01:41,060 --> 00:01:41,780
很简单

65
00:01:41,780 --> 00:01:42,280
背诵

66
00:01:42,280 --> 00:01:43,800
死记应背总行吧

67
00:01:43,800 --> 00:01:44,060
对吧

68
00:01:44,060 --> 00:01:45,140
自己整理一个笔记

69
00:01:45,140 --> 00:01:45,620
天天看

70
00:01:45,620 --> 00:01:47,359
然后背诵的基础上

71
00:01:47,359 --> 00:01:49,880
等着一步一步学完这一章之后

72
00:01:49,880 --> 00:01:51,780
你就基本上去慢慢理解了

73
00:01:51,780 --> 00:01:53,280
所以说先背

74
00:01:53,280 --> 00:01:55,620
然后再去通过自己的实践

75
00:01:55,620 --> 00:01:56,460
自己的学习

76
00:01:56,460 --> 00:01:57,599
然后把它消化掉

77
00:01:57,599 --> 00:01:58,719
这样就理解了

78
00:01:58,719 --> 00:02:00,500
我们说这个人有文化

79
00:02:00,500 --> 00:02:01,280
有文化对吧

80
00:02:01,280 --> 00:02:02,620
文化这两个字呢

81
00:02:02,620 --> 00:02:03,700
应该是拆开来说

82
00:02:03,700 --> 00:02:04,120
对吧

83
00:02:04,120 --> 00:02:05,560
先文而后话

84
00:02:05,560 --> 00:02:07,320
那先文而后话

85
00:02:07,320 --> 00:02:08,460
这个文是什么呢

86
00:02:08,460 --> 00:02:09,599
就是一种形式

87
00:02:09,599 --> 00:02:10,639
就是一种背诵

88
00:02:10,639 --> 00:02:11,719
话是什么呢

89
00:02:11,719 --> 00:02:12,420
就是理解

90
00:02:12,420 --> 00:02:12,860
对吧

91
00:02:12,860 --> 00:02:15,740
所以说这是一个非常有道理的一个事情

92
00:02:15,740 --> 00:02:17,120
所以理解不了就背诵

93
00:02:17,120 --> 00:02:18,020
好

94
00:02:18,020 --> 00:02:19,560
什么是复杂度

95
00:02:19,560 --> 00:02:20,780
复杂度呢

96
00:02:20,780 --> 00:02:21,980
那我们基本的意思就是说

97
00:02:21,980 --> 00:02:23,759
它复杂到一个程度

98
00:02:23,759 --> 00:02:25,939
那这个复杂是什么意思呢

99
00:02:25,939 --> 00:02:27,120
复杂就是说

100
00:02:27,120 --> 00:02:29,939
程序执行时需要的一个计算量

101
00:02:29,939 --> 00:02:31,819
或者说是内存空间

102
00:02:31,819 --> 00:02:32,800
这个分开说

103
00:02:32,800 --> 00:02:34,960
计算量是时间复杂度

104
00:02:34,960 --> 00:02:36,240
计算需要时间吧

105
00:02:36,240 --> 00:02:36,400
对吧

106
00:02:36,400 --> 00:02:37,259
你如果计算多了

107
00:02:37,259 --> 00:02:38,080
那时间就长一点

108
00:02:38,080 --> 00:02:38,960
计算少了

109
00:02:38,960 --> 00:02:39,780
那时间就短一点

110
00:02:39,780 --> 00:02:40,120
对吧

111
00:02:40,120 --> 00:02:43,040
然后内存空间是空间复杂度

112
00:02:43,040 --> 00:02:44,480
所以这个是时间复杂度

113
00:02:44,480 --> 00:02:45,360
这个是空间复杂度

114
00:02:45,360 --> 00:02:48,600
这一点和代码简洁程度没有关系

115
00:02:48,600 --> 00:02:50,440
所以说这个复杂指的是

116
00:02:50,440 --> 00:02:53,500
计算机的CPU和内存的一个复杂程度

117
00:02:53,500 --> 00:02:56,120
和你代码的写出来的复杂程度没有关系

118
00:02:56,120 --> 00:02:57,560
有些代码写出来很简单

119
00:02:57,560 --> 00:02:58,360
但是一执行

120
00:02:58,360 --> 00:02:58,800
完了

121
00:02:58,800 --> 00:02:59,600
崩溃了

122
00:02:59,600 --> 00:03:00,320
说明什么

123
00:03:00,320 --> 00:03:01,540
代码很简洁

124
00:03:01,540 --> 00:03:03,340
但是执行的计算量

125
00:03:03,340 --> 00:03:04,980
或内存空间占用很大

126
00:03:04,980 --> 00:03:06,260
有些代码很复杂

127
00:03:06,260 --> 00:03:07,060
看起来很复杂

128
00:03:07,060 --> 00:03:07,980
看起来一点都看不懂

129
00:03:07,980 --> 00:03:09,780
但是一执行非常非常的快

130
00:03:09,780 --> 00:03:11,820
这就是大家可能学算法的时候

131
00:03:11,820 --> 00:03:14,080
有一个感觉违背自己

132
00:03:14,080 --> 00:03:15,320
这个厂里的一个认识

133
00:03:15,320 --> 00:03:15,880
就是说

134
00:03:15,880 --> 00:03:17,420
这个怎么这么难了

135
00:03:17,420 --> 00:03:17,660
对吧

136
00:03:17,660 --> 00:03:19,360
为了要执行的这么快

137
00:03:19,360 --> 00:03:20,180
代码写的这么难

138
00:03:20,180 --> 00:03:20,860
这个合适吗

139
00:03:20,860 --> 00:03:22,420
这个问题我们后面再讨论

140
00:03:22,420 --> 00:03:23,640
但是我们这说的是

141
00:03:23,640 --> 00:03:26,180
代码的简洁程度和复杂度没有关系

142
00:03:26,180 --> 00:03:28,040
所以说这个复杂这两个字

143
00:03:28,040 --> 00:03:30,240
要认到这个CPU聚算量

144
00:03:30,240 --> 00:03:31,840
还有这个内存空间上

145
00:03:31,840 --> 00:03:33,880
不要认到这个代码的书写简洁上

146
00:03:33,880 --> 00:03:35,880
然后复杂度

147
00:03:35,880 --> 00:03:37,460
它是一个数量级

148
00:03:37,460 --> 00:03:38,960
然后不是具体的数字

149
00:03:38,960 --> 00:03:40,520
为什么不是具体的数字呢

150
00:03:40,520 --> 00:03:41,920
因为没法算

151
00:03:41,920 --> 00:03:42,439
知道吗

152
00:03:42,439 --> 00:03:43,419
因为一个算法

153
00:03:43,419 --> 00:03:45,520
你说它到底是占用多少内存空间

154
00:03:45,520 --> 00:03:47,439
它需要多少次CPU的计算

155
00:03:47,439 --> 00:03:49,159
这个你没法算出来

156
00:03:49,159 --> 00:03:49,919
对吧

157
00:03:49,919 --> 00:03:51,560
因为我们现在写的这个代码呢

158
00:03:51,560 --> 00:03:52,960
经过层层变印之后

159
00:03:52,960 --> 00:03:53,680
到了底层

160
00:03:53,680 --> 00:03:55,359
计算机运行的这个二斤这代码

161
00:03:55,359 --> 00:03:56,819
已经变了话很多了

162
00:03:56,819 --> 00:03:57,960
所以说我们根本没有办法

163
00:03:57,960 --> 00:03:58,939
去准确的算出来

164
00:03:58,939 --> 00:03:59,759
那怎么办呢

165
00:03:59,759 --> 00:04:01,020
那也不能不算了

166
00:04:01,020 --> 00:04:01,240
对吧

167
00:04:01,240 --> 00:04:02,539
大家注意这个思想很重要

168
00:04:02,539 --> 00:04:04,460
有些事情我们没有办法

169
00:04:04,460 --> 00:04:05,579
去精力度的解决

170
00:04:05,579 --> 00:04:06,599
那我们就可以怎么

171
00:04:06,599 --> 00:04:07,699
可以粗力度的解决

172
00:04:07,699 --> 00:04:09,060
用数量级的方式

173
00:04:09,060 --> 00:04:09,579
这样的话

174
00:04:09,579 --> 00:04:10,680
方便记忆方便推广

175
00:04:10,680 --> 00:04:12,099
数量级是什么意思呢

176
00:04:12,099 --> 00:04:12,780
数量级就是说

177
00:04:12,780 --> 00:04:13,980
和这个差不多

178
00:04:13,980 --> 00:04:14,920
这是字面意思

179
00:04:14,920 --> 00:04:16,060
我们举个例子来说

180
00:04:16,060 --> 00:04:18,660
我们就说这个高度吧

181
00:04:18,660 --> 00:04:20,199
我们可以分这么几个数量级

182
00:04:20,199 --> 00:04:21,019
举一个例子

183
00:04:21,019 --> 00:04:23,800
比如说山川的数量级

184
00:04:23,800 --> 00:04:24,879
一座山的高度

185
00:04:24,879 --> 00:04:26,060
最少的1000米

186
00:04:26,060 --> 00:04:26,699
对吧

187
00:04:26,699 --> 00:04:28,100
要不然的话就成了丘陵了

188
00:04:28,100 --> 00:04:29,060
1000米

189
00:04:29,060 --> 00:04:30,519
然后有的山呢2000米

190
00:04:30,519 --> 00:04:31,579
有的山呢5000米

191
00:04:31,579 --> 00:04:32,540
有的山呢8000米

192
00:04:32,540 --> 00:04:32,840
对吧

193
00:04:32,840 --> 00:04:34,379
但是这个山的高度

194
00:04:34,379 --> 00:04:36,000
基本上都在千到万

195
00:04:36,000 --> 00:04:37,639
这么一个级别之间

196
00:04:37,639 --> 00:04:38,720
它数量级是一样的

197
00:04:38,720 --> 00:04:39,019
对吧

198
00:04:39,019 --> 00:04:39,979
它不会很大

199
00:04:39,979 --> 00:04:41,039
再往下说

200
00:04:41,039 --> 00:04:43,339
比如说人的高度

201
00:04:43,339 --> 00:04:44,799
人的身高基本上

202
00:04:44,799 --> 00:04:46,379
正常人的身高基本上

203
00:04:46,379 --> 00:04:47,639
比如说1米6

204
00:04:47,639 --> 00:04:48,379
1米7

205
00:04:48,379 --> 00:04:48,759
1米8

206
00:04:48,759 --> 00:04:49,159
1米9

207
00:04:49,159 --> 00:04:50,180
1米9的就比较少了

208
00:04:50,180 --> 00:04:50,379
对吧

209
00:04:50,379 --> 00:04:51,019
1米6

210
00:04:51,019 --> 00:04:51,419
1米7

211
00:04:51,419 --> 00:04:51,819
1米8

212
00:04:51,819 --> 00:04:52,919
这个数量级之间

213
00:04:52,919 --> 00:04:54,060
哪怕是有些人

214
00:04:54,060 --> 00:04:55,019
超常发育

215
00:04:55,019 --> 00:04:56,120
像姚明到了2米多

216
00:04:56,120 --> 00:04:58,240
有些人可能身体有点问题

217
00:04:58,240 --> 00:04:59,680
只有一米多一点的身高

218
00:04:59,680 --> 00:05:01,840
但是它这个数量级相差不大

219
00:05:01,840 --> 00:05:03,980
也就是最多差一倍的一个样子

220
00:05:03,980 --> 00:05:04,500
对吧

221
00:05:04,500 --> 00:05:06,019
然后我们再往下说

222
00:05:06,019 --> 00:05:07,620
老鼠的身高

223
00:05:07,620 --> 00:05:08,959
老鼠的身高

224
00:05:08,959 --> 00:05:11,280
可能只有那么10厘米左右

225
00:05:11,280 --> 00:05:11,639
对吧

226
00:05:11,639 --> 00:05:12,960
当然有的老鼠比较大

227
00:05:12,960 --> 00:05:14,040
可能长到15厘米

228
00:05:14,040 --> 00:05:14,800
有的老鼠比较小

229
00:05:14,800 --> 00:05:15,660
可能只有5厘米

230
00:05:15,660 --> 00:05:16,759
或者只有3厘米

231
00:05:16,759 --> 00:05:17,600
这个没有关系

232
00:05:17,600 --> 00:05:17,939
对吧

233
00:05:17,939 --> 00:05:19,740
老鼠的身高只有这么大

234
00:05:19,740 --> 00:05:21,360
所以它的数量级也是差不多的

235
00:05:21,360 --> 00:05:22,139
再往下

236
00:05:22,139 --> 00:05:23,540
我们可以说是蚂蚁的身高

237
00:05:23,540 --> 00:05:24,860
蚂蚁的身高

238
00:05:24,860 --> 00:05:26,379
这个我没有进去量过

239
00:05:26,379 --> 00:05:27,540
大概在毫米级

240
00:05:27,540 --> 00:05:27,860
对吧

241
00:05:27,860 --> 00:05:29,139
所以说大家想一下

242
00:05:29,139 --> 00:05:30,139
这个数量级是什么意思

243
00:05:30,139 --> 00:05:32,180
数量级就是一个相差不大的

244
00:05:32,180 --> 00:05:33,020
一个数据范围

245
00:05:33,020 --> 00:05:34,139
区间范围

246
00:05:34,139 --> 00:05:35,060
山是一个高度

247
00:05:35,060 --> 00:05:35,800
人是一个高度

248
00:05:35,800 --> 00:05:36,660
老鼠是一个高度

249
00:05:36,660 --> 00:05:37,960
然后蚂蚁是一个高度

250
00:05:37,960 --> 00:05:38,920
大家能想象出来吧

251
00:05:38,920 --> 00:05:41,199
你说人和人之间的身高差异

252
00:05:41,199 --> 00:05:42,920
可能我们说是10公分

253
00:05:42,920 --> 00:05:43,879
20公分就比较大了

254
00:05:43,879 --> 00:05:45,160
但它的数量级是一样的

255
00:05:45,160 --> 00:05:46,939
你说老鼠和人之间的

256
00:05:46,939 --> 00:05:48,020
这个身高差异

257
00:05:48,020 --> 00:05:48,860
那就没法算了

258
00:05:48,860 --> 00:05:49,040
对吧

259
00:05:49,040 --> 00:05:50,840
因为它数量级是不一样的

260
00:05:50,840 --> 00:05:52,420
所以说你也可以这么想一下

261
00:05:52,420 --> 00:05:54,819
我和隔壁的老王只有钱

262
00:05:54,819 --> 00:05:55,879
我存了10万

263
00:05:55,879 --> 00:05:56,520
他存了20万

264
00:05:56,520 --> 00:05:57,139
没关系

265
00:05:57,860 --> 00:06:00,020
但是我和那边的老马

266
00:06:00,020 --> 00:06:00,720
马云

267
00:06:00,720 --> 00:06:02,259
钱是不是一样的

268
00:06:02,259 --> 00:06:03,400
当然这个数量级

269
00:06:03,400 --> 00:06:04,240
是完全不一样的

270
00:06:04,240 --> 00:06:04,520
对不对

271
00:06:04,520 --> 00:06:06,240
所以我们重点讲了一下

272
00:06:06,240 --> 00:06:06,960
这个数量级的概念

273
00:06:06,960 --> 00:06:09,240
然后我们算法的复杂度

274
00:06:09,240 --> 00:06:10,860
一般是针对一个算法

275
00:06:10,860 --> 00:06:11,620
所谓算法

276
00:06:11,620 --> 00:06:12,680
我们就可以理解为

277
00:06:12,680 --> 00:06:13,900
一个函数

278
00:06:13,900 --> 00:06:15,460
或者说一个稍微大一点的函数

279
00:06:15,460 --> 00:06:16,280
可大可小

280
00:06:16,280 --> 00:06:18,000
但是没有一个人说

281
00:06:18,000 --> 00:06:19,939
它是一个系统的复杂度

282
00:06:19,939 --> 00:06:21,040
比如说我们执行

283
00:06:21,040 --> 00:06:22,120
一些百度搜索

284
00:06:22,120 --> 00:06:23,080
复杂度有多少

285
00:06:23,080 --> 00:06:24,120
这个算不出来

286
00:06:24,120 --> 00:06:24,560
对吧

287
00:06:24,560 --> 00:06:25,060
这个算不出来

288
00:06:25,060 --> 00:06:26,680
因为它有很多很多很多的算法

289
00:06:26,680 --> 00:06:27,460
去拼接出来的

290
00:06:27,460 --> 00:06:28,840
那这个算法的复杂度高一点

291
00:06:28,840 --> 00:06:29,960
那个算法的复杂度低一点

292
00:06:29,960 --> 00:06:31,060
那总起来之后

293
00:06:31,060 --> 00:06:31,520
你怎么算

294
00:06:31,520 --> 00:06:32,060
你没法算

295
00:06:32,060 --> 00:06:32,340
对吧

296
00:06:32,340 --> 00:06:33,720
所以说我们说复杂度

297
00:06:33,720 --> 00:06:35,380
一般是针对一个具体的算法的

298
00:06:35,380 --> 00:06:36,960
一般是针对一个具体的代码

299
00:06:36,960 --> 00:06:38,660
不会说是一个完整的系统

300
00:06:38,660 --> 00:06:39,380
因为完整的系统呢

301
00:06:39,380 --> 00:06:40,380
有可能还包含这个

302
00:06:40,380 --> 00:06:41,720
就它的这个耗时啊

303
00:06:41,720 --> 00:06:43,180
它有可能还包含这个计算的

304
00:06:43,180 --> 00:06:44,440
有可能还包含这个网络的

305
00:06:44,440 --> 00:06:44,460
有可能还包含这个网络的

306
00:06:44,460 --> 00:06:45,580
有可能还包含这个硬盘

307
00:06:45,580 --> 00:06:46,080
IO的

308
00:06:46,080 --> 00:06:46,900
这个都不一样

309
00:06:46,900 --> 00:06:48,640
所以说不要去搞这个系统的复杂度

310
00:06:48,639 --> 00:06:49,919
只是一个算法的复杂度

311
00:06:49,919 --> 00:06:50,759
算法复杂度

312
00:06:50,759 --> 00:06:52,659
我们不考虑网络的号式

313
00:06:52,659 --> 00:06:54,279
不考虑硬盘读取的号式

314
00:06:54,279 --> 00:06:57,159
只考虑计算量和内存空间的号式

315
00:06:57,159 --> 00:06:58,079
大家注意啊

316
00:06:58,079 --> 00:06:59,639
这就是复杂度的一个概念

317
00:06:59,639 --> 00:07:01,339
然后要点是什么呢

318
00:07:01,339 --> 00:07:02,279
具体的算法

319
00:07:02,279 --> 00:07:02,819
数量级

320
00:07:02,819 --> 00:07:04,339
以及计算量和内存空间

321
00:07:04,339 --> 00:07:05,740
和代码解释程度无关

322
00:07:05,740 --> 00:07:06,439
好

323
00:07:06,439 --> 00:07:07,019
我们看这个图

324
00:07:07,019 --> 00:07:07,860
复杂度呢

325
00:07:07,860 --> 00:07:09,019
我们呈现的复杂度就这么几个

326
00:07:09,019 --> 00:07:09,519
大家看一下

327
00:07:09,519 --> 00:07:11,439
我们说复杂度是数量级

328
00:07:11,439 --> 00:07:11,759
对吧

329
00:07:11,759 --> 00:07:12,539
数量级

330
00:07:12,539 --> 00:07:14,039
我们就用O来表示

331
00:07:14,039 --> 00:07:14,819
字母大O

332
00:07:14,819 --> 00:07:16,339
然后O下面的括号

333
00:07:16,340 --> 00:07:19,140
大家看一下O括号1O括号logn

334
00:07:19,140 --> 00:07:20,140
O括号n

335
00:07:20,140 --> 00:07:21,700
O括号n乘以logn

336
00:07:21,700 --> 00:07:22,780
这个是个乘的意思

337
00:07:22,780 --> 00:07:24,440
就是乘法的乘

338
00:07:24,440 --> 00:07:25,920
然后O括号n的平方

339
00:07:25,920 --> 00:07:26,380
对吧

340
00:07:26,380 --> 00:07:28,280
所有的形式都是一个O

341
00:07:28,280 --> 00:07:29,780
大O加括号的形式

342
00:07:29,780 --> 00:07:31,600
来去表示这个算法的复杂度

343
00:07:31,600 --> 00:07:33,860
就是只要是O大O加括号

344
00:07:33,860 --> 00:07:34,680
这就是说

345
00:07:34,680 --> 00:07:35,700
这是算法的复杂度

346
00:07:35,700 --> 00:07:36,760
然后括号里面

347
00:07:36,760 --> 00:07:37,220
但是别大事

348
00:07:37,220 --> 00:07:37,680
我们看一下

349
00:07:37,680 --> 00:07:39,440
我们说是数量级

350
00:07:39,440 --> 00:07:39,920
对吧

351
00:07:39,920 --> 00:07:41,800
所以说只要是这个单位

352
00:07:41,800 --> 00:07:44,620
或说只要是这个可数的

353
00:07:44,620 --> 00:07:45,940
计算量的这个算法

354
00:07:45,939 --> 00:07:47,379
我们都叫做O1数量级

355
00:07:47,379 --> 00:07:48,839
它和1是一样的

356
00:07:48,839 --> 00:07:50,980
也说它计算一次

357
00:07:50,980 --> 00:07:52,100
计算两次

358
00:07:52,100 --> 00:07:52,660
计算三次

359
00:07:52,660 --> 00:07:53,199
计算一百次

360
00:07:53,199 --> 00:07:53,759
计算一百次

361
00:07:53,759 --> 00:07:54,939
只要是可数的

362
00:07:54,939 --> 00:07:57,560
我们都叫做它这个O1级别的一个数量级

363
00:07:57,560 --> 00:07:59,920
然后我们再看一下这个logn

364
00:07:59,920 --> 00:08:00,920
logn是个对数

365
00:08:00,920 --> 00:08:02,620
对数我们后面会举例的

366
00:08:02,620 --> 00:08:03,800
大家看这个曲线

367
00:08:03,800 --> 00:08:05,939
这个曲线就是这个logn

368
00:08:05,939 --> 00:08:06,819
这个函数的一个曲线

369
00:08:06,819 --> 00:08:07,959
这个n就是横轴

370
00:08:07,959 --> 00:08:09,399
随着这个n的变化

371
00:08:09,399 --> 00:08:10,399
这个logn的结果

372
00:08:10,399 --> 00:08:11,959
是这么一个曲线的形式

373
00:08:11,959 --> 00:08:13,500
logn的结果是这个纵轴

374
00:08:13,500 --> 00:08:14,279
就是计算量

375
00:08:14,279 --> 00:08:14,879
或者说空间

376
00:08:14,879 --> 00:08:17,839
横轴是我们原始数据输入的一个量

377
00:08:17,839 --> 00:08:19,100
然后纵轴呢

378
00:08:19,100 --> 00:08:21,000
就是我们的时间复杂度的一个结果

379
00:08:21,000 --> 00:08:22,339
当然是数量级的结果

380
00:08:22,339 --> 00:08:23,500
是计算量

381
00:08:23,500 --> 00:08:24,339
时间复杂度

382
00:08:24,339 --> 00:08:24,659
计算量

383
00:08:24,659 --> 00:08:25,860
或者说空间复杂度的空间

384
00:08:25,860 --> 00:08:27,540
大家看是这么一个结果

385
00:08:27,540 --> 00:08:27,920
也就是说

386
00:08:27,920 --> 00:08:29,379
随着我们的输入的量越来越大

387
00:08:29,379 --> 00:08:30,279
它这个线呢

388
00:08:30,279 --> 00:08:32,700
是趋向于这么一个平缓的一个方式

389
00:08:32,700 --> 00:08:33,820
这个是不是很好啊

390
00:08:33,820 --> 00:08:34,019
对吧

391
00:08:34,019 --> 00:08:35,939
因为随着这个数据量越来越大

392
00:08:35,939 --> 00:08:36,860
我们这个计算量呢

393
00:08:36,860 --> 00:08:37,860
趋向于平缓了

394
00:08:37,860 --> 00:08:39,399
发现越大吧

395
00:08:39,399 --> 00:08:41,220
这个计算量还升的没有那么高

396
00:08:41,220 --> 00:08:42,179
这是一个好现象

397
00:08:42,179 --> 00:08:42,519
对不对

398
00:08:42,519 --> 00:08:43,879
大家看这个ON

399
00:08:43,879 --> 00:08:44,840
ON呢

400
00:08:44,840 --> 00:08:46,100
这就是一个分割线了

401
00:08:46,100 --> 00:08:47,819
就是横轴输入量是多少

402
00:08:47,819 --> 00:08:48,600
计算量就是多少

403
00:08:48,600 --> 00:08:50,019
输入量是7

404
00:08:50,019 --> 00:08:50,819
计算量就是7

405
00:08:50,819 --> 00:08:51,559
输入量是10

406
00:08:51,559 --> 00:08:52,360
计算量就是10

407
00:08:52,360 --> 00:08:53,500
因为这个N嘛

408
00:08:53,500 --> 00:08:54,960
这个我们看上表达是里面

409
00:08:54,960 --> 00:08:56,179
这个N不就是个分割线吗

410
00:08:56,179 --> 00:08:56,500
对不对

411
00:08:56,500 --> 00:08:58,139
所以这个呢

412
00:08:58,139 --> 00:08:58,840
也行

413
00:08:58,840 --> 00:08:59,480
对吧

414
00:08:59,480 --> 00:08:59,919
也行

415
00:08:59,919 --> 00:09:01,039
输入量增加

416
00:09:01,039 --> 00:09:02,000
我们的计算量增加

417
00:09:02,000 --> 00:09:03,240
这个是很复合常理的

418
00:09:03,240 --> 00:09:03,980
对吧

419
00:09:03,980 --> 00:09:04,699
然后再看这个

420
00:09:04,699 --> 00:09:06,460
N乘以LogN

421
00:09:06,460 --> 00:09:08,079
这个LogN是个整体啊

422
00:09:08,079 --> 00:09:08,819
这个是个整体

423
00:09:08,819 --> 00:09:09,679
你不能分开念

424
00:09:09,679 --> 00:09:10,679
LogN是个整体

425
00:09:10,679 --> 00:09:12,360
N乘以LogN什么意思呢

426
00:09:12,519 --> 00:09:13,620
就是计算量

427
00:09:13,620 --> 00:09:14,579
在慢慢增加的时候

428
00:09:14,579 --> 00:09:15,960
它这个曲线是这么发展的

429
00:09:15,960 --> 00:09:16,840
大家看就不太好了

430
00:09:16,840 --> 00:09:17,579
对吧

431
00:09:17,579 --> 00:09:18,600
这么发展的是什么意思啊

432
00:09:18,600 --> 00:09:19,379
这么发展的就是说

433
00:09:19,379 --> 00:09:20,659
你这个计算量越大

434
00:09:20,659 --> 00:09:21,439
它这个曲线

435
00:09:21,439 --> 00:09:22,960
有点越往上天的意思

436
00:09:22,960 --> 00:09:24,899
有时候计算量大了之后呢

437
00:09:24,899 --> 00:09:25,819
这个曲线好像是

438
00:09:25,819 --> 00:09:27,299
越来越明显的增大了

439
00:09:27,299 --> 00:09:28,699
这不是我们想要的

440
00:09:28,699 --> 00:09:29,759
它的意思是什么意思呢

441
00:09:29,759 --> 00:09:31,679
就是这个N的这个线

442
00:09:31,679 --> 00:09:33,279
乘以这个LogN的这个线

443
00:09:33,279 --> 00:09:34,179
正好是等于这个

444
00:09:34,179 --> 00:09:34,899
绿色的这个线

445
00:09:34,899 --> 00:09:36,059
再往上看

446
00:09:36,059 --> 00:09:37,059
N的平方

447
00:09:37,059 --> 00:09:38,639
当我们输入量是1的时候

448
00:09:38,639 --> 00:09:39,939
它是1平方对吧

449
00:09:39,939 --> 00:09:41,419
当我们输入量是2的时候呢

450
00:09:41,419 --> 00:09:43,899
它是4平方对吧

451
00:09:43,899 --> 00:09:45,159
当我们输入量是3的时候

452
00:09:45,159 --> 00:09:46,099
它是9

453
00:09:46,099 --> 00:09:47,559
因为它是平方嘛

454
00:09:47,559 --> 00:09:48,339
3的平方是9

455
00:09:48,339 --> 00:09:49,819
所以说这个就不太好了

456
00:09:49,819 --> 00:09:51,799
当我们输入量到10的时候呢

457
00:09:51,799 --> 00:09:52,479
10的平方是多少

458
00:09:52,479 --> 00:09:53,699
是100了对吧

459
00:09:53,699 --> 00:09:54,979
增的非常非常的快

460
00:09:54,979 --> 00:09:55,939
一会就上天了

461
00:09:55,939 --> 00:09:57,419
所以这种的复杂度

462
00:09:57,419 --> 00:09:58,539
不是我们需要的

463
00:09:58,539 --> 00:09:59,079
大家想一想

464
00:09:59,079 --> 00:10:00,379
如果这个是CPU计算量的话

465
00:10:00,379 --> 00:10:01,199
我们的输入数量

466
00:10:01,199 --> 00:10:02,079
慢慢越来越多

467
00:10:02,079 --> 00:10:03,839
它的计算量升的那么快

468
00:10:03,839 --> 00:10:05,459
这个是不是我们想要的

469
00:10:05,459 --> 00:10:06,620
这个东西对吧

470
00:10:06,620 --> 00:10:07,039
这个图

471
00:10:07,039 --> 00:10:08,179
大家可能看不懂

472
00:10:08,179 --> 00:10:09,439
看不懂没有关系

473
00:10:09,440 --> 00:10:10,300
我们后面会解释

474
00:10:10,300 --> 00:10:12,240
但这个图看不懂也好

475
00:10:12,240 --> 00:10:12,960
看懂也好

476
00:10:12,960 --> 00:10:14,900
你都要去自己去画一遍

477
00:10:14,900 --> 00:10:15,700
把这个图画一遍

478
00:10:15,700 --> 00:10:16,960
用分分颜色的笔画一遍

479
00:10:16,960 --> 00:10:17,900
这个图非常重要

480
00:10:17,900 --> 00:10:18,640
这个图我们接下来

481
00:10:18,640 --> 00:10:19,420
要出现很多次

482
00:10:19,420 --> 00:10:21,160
我们去挨择分析一下

483
00:10:21,160 --> 00:10:22,180
这个图里面的几个数

484
00:10:22,180 --> 00:10:23,980
O1是吗

485
00:10:23,980 --> 00:10:25,240
就是一次就够

486
00:10:25,240 --> 00:10:26,100
一次

487
00:10:26,100 --> 00:10:27,240
当然是数量极是一次

488
00:10:27,240 --> 00:10:28,560
两次三次五次

489
00:10:28,560 --> 00:10:29,820
是不是都是这个1的数量极

490
00:10:29,820 --> 00:10:31,120
这都是一样的

491
00:10:31,120 --> 00:10:34,060
然后O1是和数的数据量

492
00:10:34,060 --> 00:10:34,880
是一样的

493
00:10:34,880 --> 00:10:36,060
比如说我们数一个10

494
00:10:36,060 --> 00:10:37,480
它就执行10次计算

495
00:10:37,480 --> 00:10:38,260
数一个100

496
00:10:38,259 --> 00:10:39,319
它就执行100次计算

497
00:10:39,319 --> 00:10:40,059
数一个100

498
00:10:40,059 --> 00:10:41,240
它就执行100次计算

499
00:10:41,240 --> 00:10:42,799
然后A的平方

500
00:10:42,799 --> 00:10:44,319
就是它的区别的平方

501
00:10:44,319 --> 00:10:45,879
比如说我们数一个10

502
00:10:45,879 --> 00:10:46,819
执行100次计算

503
00:10:46,819 --> 00:10:48,259
我们数一个20

504
00:10:48,259 --> 00:10:49,179
那执行多少

505
00:10:49,179 --> 00:10:50,340
400次计算

506
00:10:50,340 --> 00:10:50,779
对吧

507
00:10:50,779 --> 00:10:51,980
20的平方是400

508
00:10:51,980 --> 00:10:53,200
我们数一个100

509
00:10:53,200 --> 00:10:54,819
那就执行100次计算

510
00:10:54,819 --> 00:10:56,080
当我们数一个100

511
00:10:56,080 --> 00:10:57,340
1亿次计算

512
00:10:57,340 --> 00:10:57,759
对吧

513
00:10:57,759 --> 00:10:58,960
大家对比一下

514
00:10:58,960 --> 00:11:01,159
如果一个算法的复杂度是ON

515
00:11:01,159 --> 00:11:02,480
另外一个算法的复杂度

516
00:11:02,480 --> 00:11:03,740
是ON的平方

517
00:11:03,740 --> 00:11:05,139
那这两个算法哪个好

518
00:11:05,139 --> 00:11:06,720
当然从时间复杂度上来说

519
00:11:06,720 --> 00:11:07,419
当然是这个好

520
00:11:07,419 --> 00:11:08,059
对吧

521
00:11:08,059 --> 00:11:08,819
我们可以说一下

522
00:11:08,819 --> 00:11:10,439
当输入量是1万的时候

523
00:11:10,439 --> 00:11:12,620
这个复杂度的计算量是1万

524
00:11:12,620 --> 00:11:12,860
对吧

525
00:11:12,860 --> 00:11:13,579
因为它是ON

526
00:11:13,579 --> 00:11:14,939
1万还可以

527
00:11:14,939 --> 00:11:15,259
对吧

528
00:11:15,259 --> 00:11:15,919
输入量是1万

529
00:11:15,919 --> 00:11:16,500
计算量是1万

530
00:11:16,500 --> 00:11:18,399
当输入量是1万的时候

531
00:11:18,399 --> 00:11:19,399
这个计算量是多少

532
00:11:19,399 --> 00:11:20,479
是一个亿

533
00:11:20,480 --> 00:11:22,539
那让CPU计算1万

534
00:11:22,539 --> 00:11:23,940
让CPU计算1亿次

535
00:11:23,940 --> 00:11:25,039
这个是完全不一样的

536
00:11:25,039 --> 00:11:27,600
所以这个就会严重的导致程序卡顿

537
00:11:27,600 --> 00:11:28,420
大家知道了吧

538
00:11:28,420 --> 00:11:29,500
所以说

539
00:11:29,500 --> 00:11:30,960
为什么时间复杂度很重要

540
00:11:30,960 --> 00:11:32,259
因为一个算法

541
00:11:32,259 --> 00:11:33,940
你要识别出来它的时间复杂度

542
00:11:33,940 --> 00:11:34,500
你才能知道

543
00:11:34,500 --> 00:11:36,480
它在比较大的数量级之下

544
00:11:36,480 --> 00:11:38,320
它的一个运行状态是怎么样的

545
00:11:38,320 --> 00:11:38,820
再往下

546
00:11:38,820 --> 00:11:40,759
logn就是数据章的对数

547
00:11:40,759 --> 00:11:42,060
什么叫对数呢

548
00:11:42,060 --> 00:11:42,480
比如说

549
00:11:42,480 --> 00:11:43,920
我们输入一个1

550
00:11:43,920 --> 00:11:44,880
计算量是1

551
00:11:44,880 --> 00:11:46,520
当我们输入一个100的时候

552
00:11:46,520 --> 00:11:47,060
计算量是多少

553
00:11:47,060 --> 00:11:48,260
是10

554
00:11:48,260 --> 00:11:49,800
因为10的平方是100

555
00:11:49,800 --> 00:11:50,940
正好是反过来

556
00:11:50,940 --> 00:11:51,620
对吧

557
00:11:51,620 --> 00:11:52,880
然后当我们输入一个1的时候

558
00:11:52,880 --> 00:11:53,500
计算量是多少

559
00:11:53,500 --> 00:11:54,320
是1万

560
00:11:54,320 --> 00:11:55,020
因为什么

561
00:11:55,020 --> 00:11:56,660
1万的平方是1亿

562
00:11:56,660 --> 00:11:57,880
这是个数学符号

563
00:11:57,880 --> 00:11:58,960
这个我们就过多解释

564
00:11:58,960 --> 00:12:01,560
然后n乘以logn是什么呢

565
00:12:01,560 --> 00:12:04,300
就是数据量乘以数据量的对数

566
00:12:04,300 --> 00:12:05,700
它是这么一个数量级

567
00:12:05,700 --> 00:12:07,160
这个可能不太好理解

568
00:12:07,160 --> 00:12:07,920
我们等会写代码

569
00:12:07,920 --> 00:12:09,340
大家就能明白了

570
00:12:09,340 --> 00:12:09,500
好

571
00:12:12,060 --> 00:12:12,820
有点晕没关系

572
00:12:12,820 --> 00:12:13,460
我们试一下

573
00:12:13,460 --> 00:12:14,460
我们说这个

574
00:12:14,460 --> 00:12:15,860
我们比如定一个函数吧

575
00:12:15,860 --> 00:12:17,880
然后这个函数呢

576
00:12:17,880 --> 00:12:18,840
就是我们模拟的算法

577
00:12:18,840 --> 00:12:20,780
如果说我们想要实现一个

578
00:12:20,780 --> 00:12:22,180
O1的一个数量级

579
00:12:22,180 --> 00:12:22,700
怎么办呢

580
00:12:22,700 --> 00:12:24,240
比如说我们这个函数里面

581
00:12:24,240 --> 00:12:25,020
传入一个object

582
00:12:25,020 --> 00:12:25,620
是个对象

583
00:12:25,620 --> 00:12:27,880
然后我们直接输入一个object

584
00:12:27,880 --> 00:12:29,220
然后一个key

585
00:12:29,220 --> 00:12:31,360
把这个key传进来

586
00:12:31,360 --> 00:12:35,400
直接返回一个objectkey

587
00:12:35,400 --> 00:12:36,180
这样的话

588
00:12:36,180 --> 00:12:37,480
就是一个O1的数量级

589
00:12:37,480 --> 00:12:38,240
因为什么

590
00:12:38,240 --> 00:12:39,960
它的计算量是一定的

591
00:12:39,960 --> 00:12:41,180
因为我们就这么写了

592
00:12:41,180 --> 00:12:42,860
屏幕直去的代码没有循环

593
00:12:42,860 --> 00:12:43,360
对吧

594
00:12:43,360 --> 00:12:43,980
就这么写了

595
00:12:43,980 --> 00:12:45,620
比如说我们这么写吧

596
00:12:45,620 --> 00:12:47,320
object.a

597
00:12:47,320 --> 00:12:49,440
然后加上object.b

598
00:12:49,440 --> 00:12:51,280
然后再加上object.c

599
00:12:51,280 --> 00:12:52,720
大家看一下这个计算量多少

600
00:12:52,720 --> 00:12:54,040
这计算量是3

601
00:12:54,040 --> 00:12:55,740
为什么是3呢

602
00:12:55,740 --> 00:12:58,500
整体来说应该是4到5吧

603
00:12:58,500 --> 00:12:59,740
因为它这个加法还有呢

604
00:12:59,740 --> 00:13:00,000
对吧

605
00:13:00,000 --> 00:13:00,620
加法还有

606
00:13:00,620 --> 00:13:01,860
首先要取出a

607
00:13:01,860 --> 00:13:02,680
再取出b

608
00:13:02,680 --> 00:13:03,560
再取出c

609
00:13:03,560 --> 00:13:04,860
然后再执行加法

610
00:13:04,860 --> 00:13:06,160
这个加法有可能执行一步

611
00:13:06,160 --> 00:13:06,900
有可能执行两步

612
00:13:06,900 --> 00:13:08,440
因为这是三个数的加法

613
00:13:08,440 --> 00:13:08,800
对不对

614
00:13:08,800 --> 00:13:10,340
所以说它这个计算量呢

615
00:13:10,340 --> 00:13:10,860
是4到5

616
00:13:10,860 --> 00:13:11,860
但是没有关系

617
00:13:11,860 --> 00:13:13,600
它只要是没有去循环

618
00:13:13,600 --> 00:13:14,420
这个里面的东西

619
00:13:14,420 --> 00:13:18,060
它只要是我们能够识别出来的一个计算量

620
00:13:18,060 --> 00:13:20,760
也说能够我们是用代码写出来的计算量

621
00:13:20,760 --> 00:13:22,160
它的复杂度都是O1

622
00:13:22,159 --> 00:13:23,679
好这是O1的情况

623
00:13:23,679 --> 00:13:24,579
我们再看

624
00:13:24,579 --> 00:13:26,139
如果是ON呢

625
00:13:26,139 --> 00:13:28,759
ON我们需要找一个数组来去试一下

626
00:13:28,759 --> 00:13:30,459
比如一个数组

627
00:13:30,459 --> 00:13:31,079
好

628
00:13:31,079 --> 00:13:32,779
我们定一个循环

629
00:13:32,779 --> 00:13:33,939
I等0

630
00:13:33,939 --> 00:13:37,579
然后I小于数组的Lens

631
00:13:37,579 --> 00:13:38,959
I++

632
00:13:38,959 --> 00:13:44,620
然后这个时候我们去打印一下这个数组的每一个元素

633
00:13:44,620 --> 00:13:47,480
好

634
00:13:47,480 --> 00:13:49,879
这个时候其实就是一个ON的时间复杂度

635
00:13:49,879 --> 00:13:50,460
为什么呢

636
00:13:50,460 --> 00:13:53,740
因为它是对这个数组进行一个便利循环

637
00:13:53,740 --> 00:13:54,779
我们说一下

638
00:13:54,779 --> 00:13:55,799
O1的时间复杂度是什么

639
00:13:55,799 --> 00:13:57,039
就是输入量是多少

640
00:13:57,039 --> 00:13:57,679
计算量是多少

641
00:13:57,679 --> 00:13:58,000
对吧

642
00:13:58,000 --> 00:13:59,740
输入量和计算量是一样的

643
00:13:59,740 --> 00:14:01,759
那我们数组如果长度是一万

644
00:14:01,759 --> 00:14:03,559
那这个计算量是不是就是一万

645
00:14:03,559 --> 00:14:04,759
因为循环执行一万次

646
00:14:04,759 --> 00:14:05,080
对吧

647
00:14:05,080 --> 00:14:06,580
如果数组长度是一个亿

648
00:14:06,580 --> 00:14:08,240
那循环量就是一个亿

649
00:14:08,240 --> 00:14:09,480
如果数组长度是十

650
00:14:09,480 --> 00:14:10,519
那循环量就是个十

651
00:14:10,519 --> 00:14:11,740
所以这就是O1

652
00:14:11,740 --> 00:14:13,600
如果O1的平方呢

653
00:14:13,600 --> 00:14:16,180
那就好说

654
00:14:16,180 --> 00:14:17,259
就是千套循环嘛

655
00:14:17,259 --> 00:14:17,659
对吧

656
00:14:17,659 --> 00:14:19,299
比如说我们来了一次循环

657
00:14:19,299 --> 00:14:21,460
那我们又来了一次循环

658
00:14:21,460 --> 00:14:25,840
我们就先不管这个代码有什么意义了

659
00:14:25,840 --> 00:14:29,560
我们只是为了演示一下这个时间复杂度和这个代码的关系

660
00:14:29,560 --> 00:14:39,300
这样的话我们看一下

661
00:14:39,300 --> 00:14:41,000
当我们输入一个数组的时候

662
00:14:41,000 --> 00:14:42,580
我们执行了一遍循环

663
00:14:42,580 --> 00:14:44,340
但是每一次循环的时候呢

664
00:14:44,340 --> 00:14:46,120
我们又嵌套的执行了一遍循环

665
00:14:46,120 --> 00:14:47,820
这个是不是就是一个平方的概念

666
00:14:47,820 --> 00:14:48,800
对吧

667
00:14:48,800 --> 00:14:50,620
比如说我们数组的长度是十的话

668
00:14:50,620 --> 00:14:52,720
那我们按理说第一层是执行了十次

669
00:14:52,720 --> 00:14:52,940
对吧

670
00:14:52,940 --> 00:14:55,080
但是每一次里面又执行了十次

671
00:14:55,080 --> 00:14:56,920
那这样的话加起来不就是一百次吗

672
00:14:56,920 --> 00:14:58,680
当我们数组的长度是一万呢

673
00:14:58,680 --> 00:15:00,000
那这个是一万次

674
00:15:00,000 --> 00:15:01,500
然后每次里面都有执行一万次

675
00:15:01,500 --> 00:15:02,740
那比如一个亿嘛

676
00:15:02,740 --> 00:15:03,280
对不对

677
00:15:03,280 --> 00:15:05,940
所以这就是一个on平方的一个实验法度

678
00:15:05,940 --> 00:15:08,540
那还有一个就是logn

679
00:15:08,540 --> 00:15:10,620
logn的实验法度是什么呢

680
00:15:10,620 --> 00:15:12,500
这个呢就是我们这儿呢先不写

681
00:15:12,500 --> 00:15:14,420
这个呢是一个二分的一个思想

682
00:15:14,420 --> 00:15:17,640
二分呢我们会在后面有专门的一个题目出去讲

683
00:15:17,640 --> 00:15:19,200
所以说我们这儿呢代码先不写

684
00:15:19,200 --> 00:15:20,500
代码稍微复杂一点我们先不写

685
00:15:20,500 --> 00:15:22,340
我们可以简单画一个图来表示一下

686
00:15:22,340 --> 00:15:24,520
比如说我们有一个数组

687
00:15:24,520 --> 00:15:26,260
是一个排序的数组

688
00:15:26,259 --> 00:15:32,960
比如说一二三四五六七八

689
00:15:32,960 --> 00:15:34,220
当然后面还有很多

690
00:15:34,220 --> 00:15:35,799
这是一个排序的数组

691
00:15:35,799 --> 00:15:36,720
有序数组

692
00:15:36,720 --> 00:15:37,399
有序

693
00:15:37,399 --> 00:15:39,419
大家注意这个观验词有序

694
00:15:39,419 --> 00:15:40,860
然后在这里面呢

695
00:15:40,860 --> 00:15:42,319
这个数组里面我们找出

696
00:15:42,319 --> 00:15:44,100
有没有一个数是六

697
00:15:44,100 --> 00:15:47,559
因为数度很长

698
00:15:47,559 --> 00:15:49,139
所以说你也不知道这里面有没有六

699
00:15:49,139 --> 00:15:50,059
那怎么办呢

700
00:15:50,059 --> 00:15:51,399
有一个好办法就是

701
00:15:51,399 --> 00:15:54,100
我们找到这个数组的中间位置

702
00:15:54,100 --> 00:15:55,279
找出这个数

703
00:15:55,279 --> 00:15:57,259
比如说这个数是正好是一个八十

704
00:15:57,259 --> 00:15:58,939
因为它是个有序数组

705
00:15:58,939 --> 00:16:01,399
所以说这边的数肯定是比八十小

706
00:16:01,399 --> 00:16:03,139
这边的数呢肯定是比八十大

707
00:16:03,139 --> 00:16:04,779
就这个小这个是大

708
00:16:04,779 --> 00:16:06,399
所以说先找到八十

709
00:16:06,399 --> 00:16:08,959
然后八十发现比六要大对吧

710
00:16:08,959 --> 00:16:11,139
那这个六如果存在的话肯定是存在这边

711
00:16:11,139 --> 00:16:12,059
对吧

712
00:16:12,059 --> 00:16:15,480
那到这边我们再去以这边为基础

713
00:16:15,480 --> 00:16:16,699
再找到它中间的位置

714
00:16:16,699 --> 00:16:18,779
比如说这个位置正好是发现是二十

715
00:16:18,779 --> 00:16:20,659
二十还比六大

716
00:16:20,659 --> 00:16:22,740
所以说它六只可能存在这块位置

717
00:16:22,740 --> 00:16:24,939
然后这块我们找到中间的位置

718
00:16:24,939 --> 00:16:26,159
发现它是个三

719
00:16:26,159 --> 00:16:28,000
这个六比三要大

720
00:16:28,000 --> 00:16:30,199
所以说六只可能在这块的位置

721
00:16:30,199 --> 00:16:32,419
这块的位置我们再去找中间的位置

722
00:16:32,419 --> 00:16:33,620
然后去一步一步找出来

723
00:16:33,620 --> 00:16:34,379
大家看一下

724
00:16:34,379 --> 00:16:35,379
这就是二分

725
00:16:35,379 --> 00:16:40,139
二分就是说每一步我都去把它砍掉二分之一

726
00:16:40,139 --> 00:16:42,079
然后去从下个二分之一里找

727
00:16:42,079 --> 00:16:45,259
这样的话是不是就很快就能把这个题目找出来

728
00:16:45,259 --> 00:16:47,360
你想想每次都砍二分之一

729
00:16:47,360 --> 00:16:48,259
每次都砍二分之一

730
00:16:48,259 --> 00:16:50,700
哪怕你的数据量是一个亿

731
00:16:50,700 --> 00:16:52,379
是十个亿也价不是这么砍

732
00:16:52,379 --> 00:16:53,639
每次砍二分之一

733
00:16:53,639 --> 00:16:54,539
每次砍二分之一

734
00:16:54,539 --> 00:16:55,899
很快就能砍完了

735
00:16:55,899 --> 00:16:57,620
这边就跟离婚似的

736
00:16:57,620 --> 00:17:00,580
美国有一个大明星叫尼古拉斯凯奇

737
00:17:00,580 --> 00:17:01,759
他离了好几次婚

738
00:17:01,759 --> 00:17:03,419
然后他家产立马就没了

739
00:17:03,419 --> 00:17:03,899
为什么呢

740
00:17:03,899 --> 00:17:05,660
因为每次离婚都跟他老婆二分

741
00:17:05,660 --> 00:17:07,140
他自己再有钱

742
00:17:07,140 --> 00:17:07,900
离几次婚

743
00:17:07,900 --> 00:17:08,720
二分几次

744
00:17:08,720 --> 00:17:09,819
然后就没钱了

745
00:17:09,819 --> 00:17:11,579
这个道理是一样的

746
00:17:11,579 --> 00:17:13,099
所以说离了几次婚之后

747
00:17:13,099 --> 00:17:15,640
钱没的速度和我们所谓这个二分的算法

748
00:17:15,640 --> 00:17:16,460
是一个道理

749
00:17:16,460 --> 00:17:18,080
OK

750
00:17:18,080 --> 00:17:19,720
那我们再往下进来看

751
00:17:19,720 --> 00:17:22,700
好

752
00:17:22,700 --> 00:17:23,460
这个呢

753
00:17:23,460 --> 00:17:24,280
其实就是数量

754
00:17:24,280 --> 00:17:25,680
就是第一次循环

755
00:17:25,680 --> 00:17:26,759
乘以一个二分

756
00:17:26,759 --> 00:17:27,640
就是它的相乘

757
00:17:27,640 --> 00:17:29,080
就是一个签套的意思

758
00:17:29,080 --> 00:17:30,220
我们写一下

759
00:17:30,220 --> 00:17:33,240
就是如果是n乘以logn的话

760
00:17:33,240 --> 00:17:33,880
是什么意思呢

761
00:17:33,880 --> 00:17:36,160
就是先来一个负迅环

762
00:17:36,160 --> 00:17:38,600
然后负迅环里面再来二分

763
00:17:38,600 --> 00:17:39,680
是这么一个道理

764
00:17:39,680 --> 00:17:40,700
它是一个签套

765
00:17:40,700 --> 00:17:44,220
这个签套和刚才我们说的这个n的平方的签套

766
00:17:44,220 --> 00:17:44,819
是一个意思

767
00:17:44,819 --> 00:17:45,960
都是签套

768
00:17:45,960 --> 00:17:46,519
只不过呢

769
00:17:46,519 --> 00:17:47,160
n的平方呢

770
00:17:47,160 --> 00:17:48,720
是签套的是完全是两个循环

771
00:17:48,720 --> 00:17:49,440
这个呢

772
00:17:49,440 --> 00:17:50,720
签套的是一个二分

773
00:17:50,720 --> 00:17:52,000
然后一个普通的循环

774
00:17:52,000 --> 00:17:53,279
是这个意思啊

775
00:17:53,279 --> 00:17:54,059
好

776
00:17:54,059 --> 00:17:54,759
继续

777
00:17:54,759 --> 00:17:55,660
课完了

778
00:17:55,660 --> 00:17:57,000
然后空间复杂度

779
00:17:57,000 --> 00:17:58,720
我们再继续演示一下

780
00:17:58,720 --> 00:18:28,700
感谢观看

