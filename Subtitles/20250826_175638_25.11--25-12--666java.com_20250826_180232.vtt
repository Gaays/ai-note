WEBVTT

00:00:00.000 --> 00:00:04.240
我们新建了一个文件叫linkwithlist

00:00:04.240 --> 00:00:06.940
就是说应该写错了

00:00:06.940 --> 00:00:07.400
不是link

00:00:07.400 --> 00:00:09.000
quintwithlist

00:00:09.000 --> 00:00:13.640
我们要实现对列对吧

00:00:13.640 --> 00:00:18.679
抱歉之前这个有了

00:00:18.679 --> 00:00:20.100
我需要把这个之前这个删掉

00:00:20.100 --> 00:00:26.960
我要把这个改一下

00:00:26.960 --> 00:00:30.339
quint就是对列的意思

00:00:30.339 --> 00:00:31.359
quintwithlist

00:00:31.359 --> 00:00:33.859
然后这个地方也改过来了

00:00:33.859 --> 00:00:34.740
保存一下

00:00:34.740 --> 00:00:36.200
这样的话我们在这个地方

00:00:36.200 --> 00:00:37.719
就用链表去实现对列

00:00:37.719 --> 00:00:41.079
就是讲讲我们之前所说的这个思路

00:00:41.079 --> 00:00:42.320
把它转换成代码

00:00:42.320 --> 00:00:43.320
首先第一步呢

00:00:43.320 --> 00:00:43.840
我们还是要

00:00:43.840 --> 00:00:45.100
我们要用链表嘛

00:00:45.100 --> 00:00:48.140
就要定这个链表的一个节点类型

00:00:48.140 --> 00:00:49.460
就是list to know的这个类型

00:00:49.460 --> 00:00:50.760
根据我们之前说的

00:00:50.760 --> 00:00:51.920
就是value

00:00:51.920 --> 00:00:53.380
我们暂时用number形式代替

00:00:53.380 --> 00:00:55.159
也可以换成pdl形式

00:00:55.159 --> 00:00:56.679
然后next

00:00:56.679 --> 00:00:59.119
然后他就是另外一个

00:00:59.119 --> 00:01:00.640
下一个链表

00:01:00.640 --> 00:01:00.939
对吧

00:01:00.939 --> 00:01:02.539
当然这个next也可能是n

00:01:02.539 --> 00:01:04.239
就这个地方呢

00:01:04.239 --> 00:01:05.340
我们是用这种形式来写的

00:01:05.340 --> 00:01:06.519
我们可以回顾一下

00:01:06.519 --> 00:01:07.239
我们之前的代码

00:01:07.239 --> 00:01:08.099
之前代码

00:01:08.099 --> 00:01:09.780
我们是用这个形式来写的

00:01:09.780 --> 00:01:10.799
也就是说之前代码呢

00:01:10.799 --> 00:01:12.659
我们是这个next后面加了个问号

00:01:12.659 --> 00:01:14.680
也就是说next可有可无

00:01:14.680 --> 00:01:16.000
加个问号的意思

00:01:16.000 --> 00:01:17.200
其实类似于这样

00:01:17.200 --> 00:01:20.280
就是他next可能是这个list to know的类型

00:01:20.280 --> 00:01:21.960
也可能是个anifind的类型

00:01:21.960 --> 00:01:23.019
就是这个意思

00:01:23.019 --> 00:01:25.000
也就是这个后面加个或anifind

00:01:25.000 --> 00:01:27.519
和这个后面加一个问号是一个意思

00:01:27.519 --> 00:01:28.560
然后呢

00:01:28.560 --> 00:01:30.000
我们这儿换一种写法

00:01:30.000 --> 00:01:31.120
更加丰富一些

00:01:31.120 --> 00:01:32.299
就是我们

00:01:32.299 --> 00:01:33.900
把它

00:01:33.900 --> 00:01:35.819
要不然是list node

00:01:35.819 --> 00:01:36.819
要不然就是明确的

00:01:36.819 --> 00:01:37.260
就是next

00:01:37.260 --> 00:01:39.500
这种形式也可以也没有问题

00:01:39.500 --> 00:01:40.280
也就是说

00:01:40.280 --> 00:01:41.500
你一个对象

00:01:41.500 --> 00:01:43.240
value等于100

00:01:43.240 --> 00:01:44.380
然后next

00:01:44.380 --> 00:01:45.560
next没有

00:01:45.560 --> 00:01:47.260
这个时候next是为anifind的

00:01:47.260 --> 00:01:47.480
没有

00:01:47.480 --> 00:01:49.780
当然你也可以写成next等于nen

00:01:49.780 --> 00:01:51.080
这个也没有问题

00:01:51.080 --> 00:01:51.360
对吧

00:01:51.360 --> 00:01:52.900
所以两种形式都行

00:01:52.900 --> 00:01:53.880
我们这儿呢

00:01:53.880 --> 00:01:54.680
换一种写法

00:01:54.680 --> 00:01:56.620
exportclass

00:01:56.620 --> 00:01:58.680
然后我们定一个mycoin

00:01:58.680 --> 00:02:01.560
定一个class就可以了

00:02:01.560 --> 00:02:02.500
然后这里面呢

00:02:02.500 --> 00:02:04.400
既然是coin嘛

00:02:04.400 --> 00:02:04.700
对吧

00:02:04.700 --> 00:02:06.680
我们得有一个方法

00:02:06.680 --> 00:02:07.160
叫add

00:02:07.160 --> 00:02:09.240
给我们之前演示的

00:02:09.240 --> 00:02:09.540
那个

00:02:09.540 --> 00:02:10.700
就这个

00:02:10.700 --> 00:02:11.840
to stack

00:02:11.840 --> 00:02:12.280
onecoin

00:02:12.280 --> 00:02:13.219
这里面是一样的

00:02:13.240 --> 00:02:14.200
大家看

00:02:14.200 --> 00:02:16.240
我们这个coin里面定义了一个add

00:02:16.240 --> 00:02:17.360
一个delete

00:02:17.360 --> 00:02:18.340
还有一个什么

00:02:18.340 --> 00:02:19.240
还有一个lens

00:02:19.240 --> 00:02:20.340
lens是个get

00:02:20.340 --> 00:02:20.659
对吧

00:02:20.659 --> 00:02:21.780
这个形式是一样的

00:02:21.780 --> 00:02:22.840
所以说我们也按着这个写

00:02:22.840 --> 00:02:24.020
add里面呢

00:02:24.020 --> 00:02:25.560
我们要传入一个number

00:02:25.560 --> 00:02:27.520
然后delete

00:02:27.520 --> 00:02:28.960
delete的时候呢

00:02:28.960 --> 00:02:30.180
我们要删除一开始

00:02:30.180 --> 00:02:31.200
那个对吧

00:02:31.200 --> 00:02:33.000
这个时候也是返回一个number

00:02:33.000 --> 00:02:33.500
或者是next

00:02:33.500 --> 00:02:34.560
如果删除没了

00:02:34.560 --> 00:02:34.939
就是ne

00:02:34.939 --> 00:02:35.460
是吧

00:02:35.460 --> 00:02:37.100
OK

00:02:37.100 --> 00:02:38.180
然后

00:02:38.180 --> 00:02:41.200
还有一个get

00:02:41.200 --> 00:02:42.020
lens

00:02:42.020 --> 00:02:42.540
也就是说

00:02:42.539 --> 00:02:44.539
我们是返回一个长度

00:02:44.539 --> 00:02:45.539
长度当然是一个number

00:02:45.539 --> 00:02:46.319
对不对

00:02:46.319 --> 00:02:48.739
我们有这些方法之后呢

00:02:48.739 --> 00:02:51.180
我们还需要去定义几个属性

00:02:51.180 --> 00:02:52.379
私有属性

00:02:52.379 --> 00:02:53.719
这个私有属性呢

00:02:53.719 --> 00:02:54.859
就是我们内部使用的

00:02:54.859 --> 00:02:56.180
不供外部访问

00:02:56.180 --> 00:02:57.000
private

00:02:57.000 --> 00:02:57.620
下个前键

00:02:57.620 --> 00:02:58.080
private

00:02:58.080 --> 00:02:59.379
head

00:02:59.379 --> 00:03:00.319
也就是说

00:03:00.319 --> 00:03:02.419
我们是用链表去实现对列

00:03:02.419 --> 00:03:03.419
所以说

00:03:03.419 --> 00:03:04.580
我们这个对列呢

00:03:04.580 --> 00:03:05.639
我们要有一个head

00:03:05.639 --> 00:03:06.259
的指向

00:03:06.259 --> 00:03:07.139
head

00:03:07.139 --> 00:03:07.500
节点

00:03:07.500 --> 00:03:09.520
它或者说

00:03:09.520 --> 00:03:10.120
name

00:03:10.120 --> 00:03:10.900
都可以

00:03:10.900 --> 00:03:13.920
然后private

00:03:13.920 --> 00:03:14.840
teal

00:03:14.840 --> 00:03:20.319
因为我们刚才PPT中

00:03:20.319 --> 00:03:20.719
讲过了

00:03:20.719 --> 00:03:21.319
对吧

00:03:21.319 --> 00:03:22.060
这儿写错了

00:03:22.060 --> 00:03:23.500
我们必须要有个high的

00:03:23.500 --> 00:03:23.859
有个t

00:03:23.859 --> 00:03:25.379
因为对列嘛

00:03:25.379 --> 00:03:26.299
有头有尾

00:03:26.299 --> 00:03:27.060
这样才行

00:03:27.060 --> 00:03:27.799
要不然的话

00:03:27.799 --> 00:03:28.680
它内部没法实现

00:03:28.680 --> 00:03:29.219
对吧

00:03:29.219 --> 00:03:30.699
虽然说不是对外可见的

00:03:30.699 --> 00:03:31.459
private

00:03:31.459 --> 00:03:32.139
不对外可见

00:03:32.139 --> 00:03:33.519
但是在内部实现

00:03:33.519 --> 00:03:34.639
得有头有尾

00:03:34.639 --> 00:03:35.879
得有一个进

00:03:35.879 --> 00:03:36.400
有一个出

00:03:36.400 --> 00:03:37.199
对不对

00:03:37.199 --> 00:03:38.459
然后private

00:03:38.459 --> 00:03:39.659
lens

00:03:39.659 --> 00:03:41.579
万人复日成零

00:03:41.579 --> 00:03:42.879
为什么呢

00:03:42.879 --> 00:03:44.219
因为我们刚才讲过

00:03:44.219 --> 00:03:45.259
我们在这个地方

00:03:45.259 --> 00:03:45.780
画过

00:03:45.780 --> 00:03:46.680
这个就是我鼠标

00:03:46.680 --> 00:03:47.099
这个地方

00:03:47.099 --> 00:03:48.939
就是lens要单独存储

00:03:48.939 --> 00:03:50.639
不能是在列表中

00:03:50.639 --> 00:03:51.759
去add去查找

00:03:51.759 --> 00:03:53.340
这样会太慢

00:03:53.340 --> 00:03:54.520
所以说我们lens

00:03:54.520 --> 00:03:55.359
要单独存储

00:03:55.359 --> 00:03:56.680
OK

00:03:56.680 --> 00:03:57.560
首先第一个

00:03:57.560 --> 00:03:59.000
我们说要用add

00:03:59.000 --> 00:04:00.699
add其实就是

00:04:00.699 --> 00:04:03.659
add就是入对

00:04:03.659 --> 00:04:05.139
就是加入对立

00:04:05.139 --> 00:04:06.280
我们刚才说过

00:04:06.280 --> 00:04:07.159
入对要在哪

00:04:07.159 --> 00:04:07.379
入

00:04:07.379 --> 00:04:08.699
要在

00:04:08.699 --> 00:04:10.919
tale位置

00:04:10.919 --> 00:04:11.180
对吧

00:04:11.180 --> 00:04:13.219
当时是非常非常强烈的

00:04:13.219 --> 00:04:13.539
说的

00:04:13.539 --> 00:04:14.500
必须要这样做

00:04:14.500 --> 00:04:16.100
然后我们这儿

00:04:16.100 --> 00:04:16.680
在写出是

00:04:16.680 --> 00:04:18.300
delete就是出对

00:04:18.300 --> 00:04:18.920
对吧

00:04:18.939 --> 00:04:19.639
出对在哪

00:04:19.639 --> 00:04:20.779
在

00:04:20.779 --> 00:04:22.060
hide的位置

00:04:22.060 --> 00:04:23.300
我们回顾一下

00:04:23.300 --> 00:04:23.920
刚才画了图

00:04:23.920 --> 00:04:25.300
必须在tale入

00:04:25.300 --> 00:04:26.660
必须在hide去出

00:04:26.660 --> 00:04:27.180
是不是

00:04:27.180 --> 00:04:28.759
要不然的话会出现问题

00:04:28.759 --> 00:04:29.439
对吧

00:04:29.439 --> 00:04:31.660
所以我们就在这个基础上去

00:04:31.660 --> 00:04:32.399
继续写

00:04:32.399 --> 00:04:33.540
入对吗

00:04:33.540 --> 00:04:34.420
你传入一个number

00:04:34.420 --> 00:04:36.959
那我们首先得定一个

00:04:36.959 --> 00:04:39.439
因为你是用那个链表来实现

00:04:39.439 --> 00:04:40.439
所以说你

00:04:40.439 --> 00:04:42.420
首先要定一个

00:04:42.420 --> 00:04:44.000
链表路的形式

00:04:44.000 --> 00:04:45.139
然后value

00:04:45.139 --> 00:04:46.279
是这个n

00:04:46.279 --> 00:04:47.079
对吧

00:04:47.079 --> 00:04:47.800
传入这个number

00:04:47.800 --> 00:04:48.240
这个n

00:04:48.240 --> 00:04:49.759
然后next呢

00:04:49.759 --> 00:04:50.560
复制成n

00:04:50.560 --> 00:04:51.100
就可以了

00:04:51.100 --> 00:04:52.740
这样就可以了

00:04:52.740 --> 00:04:53.819
这样少一个等号

00:04:53.819 --> 00:04:55.420
我说关报错呢

00:04:55.420 --> 00:04:55.780
next

00:04:55.780 --> 00:04:56.180
复制成n

00:04:56.180 --> 00:04:57.340
因为我们这个ness

00:04:57.340 --> 00:04:57.840
可以是n

00:04:57.840 --> 00:04:59.020
我们先复制成n

00:04:59.020 --> 00:05:01.360
然后处理

00:05:01.360 --> 00:05:02.199
hide

00:05:02.199 --> 00:05:03.699
处理hide

00:05:03.699 --> 00:05:05.000
比如说你一开始的时候

00:05:05.000 --> 00:05:06.000
这个hide是不是n

00:05:06.000 --> 00:05:07.100
没有啊

00:05:07.100 --> 00:05:08.199
比如说一开始的时候

00:05:08.199 --> 00:05:09.740
这个链表是不是空的呀

00:05:09.740 --> 00:05:10.519
hide也是n

00:05:10.519 --> 00:05:11.180
tale也是n

00:05:11.180 --> 00:05:12.720
那我们在入对的时候

00:05:12.720 --> 00:05:13.759
虽然说我们在tale

00:05:13.759 --> 00:05:14.319
位置入对

00:05:14.319 --> 00:05:15.819
但是如果这个时候

00:05:15.819 --> 00:05:16.780
这个hide是空的

00:05:16.780 --> 00:05:17.459
那怎么办呢

00:05:17.459 --> 00:05:19.060
那这个hide不能一直空着

00:05:19.060 --> 00:05:20.079
所以说

00:05:20.079 --> 00:05:22.439
如果当前的这个hide

00:05:22.439 --> 00:05:23.840
还是空着

00:05:23.840 --> 00:05:25.800
比如说我们当前这个对列

00:05:25.800 --> 00:05:26.920
这个链表还是空的

00:05:26.920 --> 00:05:28.519
那怎么办呢

00:05:28.519 --> 00:05:29.840
那也得把这个hide

00:05:29.840 --> 00:05:31.899
复制成这个new node

00:05:31.899 --> 00:05:36.340
然后处理tale

00:05:36.340 --> 00:05:38.560
处理tale的这个逻辑呢

00:05:38.560 --> 00:05:39.280
其实就跟刚才

00:05:39.280 --> 00:05:40.400
我们画的这个量是一样的

00:05:40.400 --> 00:05:41.840
就是把tale指向了

00:05:41.840 --> 00:05:42.580
一个新的节点

00:05:42.580 --> 00:05:43.360
然后呢

00:05:43.360 --> 00:05:44.660
把tale当前的节点

00:05:44.660 --> 00:05:45.640
来指向这个新的节点

00:05:45.640 --> 00:05:46.980
是这么一个逻辑

00:05:46.980 --> 00:05:49.680
我们先取到这个tale node

00:05:49.680 --> 00:05:51.640
就当前最后一个节点

00:05:51.640 --> 00:05:53.840
然后z4.tale先取出来

00:05:53.840 --> 00:05:54.460
对吧

00:05:54.460 --> 00:05:55.720
因为这个z4.tale

00:05:55.720 --> 00:05:57.280
永远指向当前最后节点

00:05:57.280 --> 00:05:59.340
我们先把当前最后节点取出来

00:05:59.340 --> 00:06:02.080
然后如果当前最后节点有的话

00:06:02.080 --> 00:06:03.980
有说明什么

00:06:03.980 --> 00:06:05.580
说明当前还没有空对吧

00:06:05.580 --> 00:06:06.100
如果没有的话

00:06:06.100 --> 00:06:06.939
说明当前是空的

00:06:06.939 --> 00:06:12.000
然后就把当前这个最后一个节点的next

00:06:12.000 --> 00:06:14.379
指向这个new node

00:06:14.379 --> 00:06:22.040
并且最后再把这个z4.tale指向new node

00:06:22.040 --> 00:06:26.540
我们看一下这个逻辑啊

00:06:26.540 --> 00:06:29.180
首先我们在tale位置入对

00:06:29.180 --> 00:06:30.700
tale位置入对的话

00:06:30.700 --> 00:06:31.480
它是在末尾

00:06:31.480 --> 00:06:33.620
所以说我们这个nest就可以是n

00:06:33.620 --> 00:06:35.060
因为它末尾嘛

00:06:35.060 --> 00:06:36.860
末尾nest肯定没有对吧

00:06:36.860 --> 00:06:38.100
那个对立的末尾

00:06:38.100 --> 00:06:38.959
或者说列表的末尾

00:06:38.959 --> 00:06:40.379
那个next肯定是没有的

00:06:40.379 --> 00:06:42.199
然后如果hide是空的

00:06:42.199 --> 00:06:44.620
那我们就把hide指向这个new node

00:06:44.620 --> 00:06:46.339
因为这个一开始的时候

00:06:46.339 --> 00:06:48.060
这个hide和tale都是nest

00:06:48.060 --> 00:06:49.060
都是空的对吧

00:06:49.060 --> 00:06:50.280
我们不能空着

00:06:50.280 --> 00:06:51.840
所以说要把它指过来

00:06:51.840 --> 00:06:53.180
然后再处理tale

00:06:53.180 --> 00:06:54.860
就当前的tale节点

00:06:54.860 --> 00:06:56.480
的next指向新的节点

00:06:56.480 --> 00:06:58.340
然后tale指向新的节点

00:06:58.340 --> 00:06:59.720
我们简单化一下

00:06:59.720 --> 00:07:01.680
可能列表这个东西啊

00:07:01.680 --> 00:07:04.139
这个一开始的时候就是不太好理解

00:07:04.139 --> 00:07:07.560
假如说hide和tale全是nest的话

00:07:07.560 --> 00:07:09.199
我们只是第一个节点

00:07:09.199 --> 00:07:10.180
这是第一个

00:07:10.180 --> 00:07:11.139
一开始是空的

00:07:11.139 --> 00:07:12.379
这个情况怎么办呢

00:07:12.379 --> 00:07:15.800
这个情况我们的hide和tale

00:07:15.800 --> 00:07:17.139
是不是都得指向这个节点

00:07:17.139 --> 00:07:18.519
因为它就一个元素

00:07:18.519 --> 00:07:19.199
它没有别的

00:07:19.199 --> 00:07:21.379
然后再看这个情况

00:07:21.379 --> 00:07:25.060
就是如果说当前是这么一种情况

00:07:25.060 --> 00:07:27.339
有值

00:07:27.339 --> 00:07:29.040
这个hide也有值

00:07:29.040 --> 00:07:30.939
然后这个tale呢

00:07:30.939 --> 00:07:31.740
也有值

00:07:31.740 --> 00:07:33.819
这个时候tale指向的这个节点

00:07:33.819 --> 00:07:34.860
比如说是个x节点

00:07:34.860 --> 00:07:36.819
那我们就从这就取出来

00:07:36.819 --> 00:07:37.180
这个节点

00:07:37.180 --> 00:07:37.939
是个x节点

00:07:37.939 --> 00:07:40.780
然后让这个x节点的next指向新的

00:07:40.780 --> 00:07:42.720
比如说让这个x节点的next

00:07:42.720 --> 00:07:44.680
指向我们这个新的节点

00:07:44.680 --> 00:07:46.360
这是第一步对吧

00:07:46.360 --> 00:07:47.459
然后最后一步呢

00:07:47.459 --> 00:07:48.459
就是this.tale

00:07:48.460 --> 00:07:52.040
就是说把当前的这个tale节点呢

00:07:52.040 --> 00:07:53.860
断开指向新的

00:07:53.860 --> 00:07:55.020
是不是就这样

00:07:55.020 --> 00:07:56.520
满事是吧

00:07:56.520 --> 00:07:57.780
好

00:07:57.780 --> 00:07:59.640
这个代码逻辑

00:07:59.640 --> 00:08:01.980
其实就是你如果理解了这个模型啊

00:08:01.980 --> 00:08:03.460
这个代码逻辑是比较简单的

00:08:03.460 --> 00:08:05.260
但是你如果不理解这个模型啊

00:08:05.260 --> 00:08:05.940
这个代码写起来

00:08:05.940 --> 00:08:07.180
你可能读起来会有点绕

00:08:07.180 --> 00:08:09.360
自己写的可能就更绕了

00:08:09.360 --> 00:08:10.980
还有一步

00:08:10.980 --> 00:08:13.340
就是记录长度

00:08:13.340 --> 00:08:16.240
我们说lens要单独存储

00:08:16.240 --> 00:08:17.520
所以说它要加加

00:08:17.520 --> 00:08:18.340
对吧

00:08:18.340 --> 00:08:18.840
它要加加

00:08:18.840 --> 00:08:20.180
然后删除

00:08:20.180 --> 00:08:21.580
删除的时候

00:08:21.580 --> 00:08:23.900
我们是要从head的位置删除

00:08:23.900 --> 00:08:24.500
对吧

00:08:24.500 --> 00:08:25.580
head的位置删除

00:08:25.580 --> 00:08:28.520
然后我们就先取出这个headnode

00:08:28.520 --> 00:08:29.500
当前的headnode

00:08:29.500 --> 00:08:31.200
就当前这个this.tale

00:08:31.200 --> 00:08:32.259
head指向那个节点

00:08:32.259 --> 00:08:35.899
如果说headnode等于next

00:08:35.899 --> 00:08:36.899
那好

00:08:36.899 --> 00:08:37.800
那就returnnext

00:08:37.800 --> 00:08:39.180
因为就没有了嘛

00:08:39.180 --> 00:08:40.899
你当前head都指向next

00:08:40.899 --> 00:08:42.940
那这个删除还删谁啊

00:08:42.940 --> 00:08:44.000
没得删了对吧

00:08:44.000 --> 00:08:44.660
就返回个next

00:08:44.660 --> 00:08:47.340
然后如果this.tale

00:08:47.340 --> 00:08:48.800
它的长度

00:08:48.800 --> 00:08:50.780
小于等于零

00:08:50.780 --> 00:08:52.139
当然你也可以直接形成等于零

00:08:52.139 --> 00:08:52.899
也可以啊

00:08:52.899 --> 00:08:53.800
然后returnne

00:08:53.800 --> 00:08:54.980
长度没有了

00:08:54.980 --> 00:08:56.080
那就是returnne

00:08:56.080 --> 00:08:56.440
对吧

00:08:56.440 --> 00:08:58.340
然后取值

00:08:58.340 --> 00:09:00.480
上面是一个操作情况啊

00:09:00.480 --> 00:09:01.740
操作情况完事之后就取值

00:09:01.740 --> 00:09:02.620
取值

00:09:02.620 --> 00:09:06.580
value分成headnode

00:09:06.580 --> 00:09:07.159
第二

00:09:07.159 --> 00:09:11.840
因为我们出对啊

00:09:11.840 --> 00:09:12.679
出对的是一个number

00:09:12.679 --> 00:09:13.580
大家注意啊

00:09:13.580 --> 00:09:14.039
是个number

00:09:14.039 --> 00:09:15.560
它不是一个节点

00:09:15.560 --> 00:09:17.580
因为节点的这个value

00:09:17.580 --> 00:09:18.860
才是这个number

00:09:18.860 --> 00:09:20.379
这个地方

00:09:20.379 --> 00:09:22.740
所以说我们要把这个value

00:09:22.740 --> 00:09:23.379
给取出来

00:09:23.379 --> 00:09:25.060
啥取出值

00:09:25.060 --> 00:09:25.960
最后呢

00:09:25.960 --> 00:09:27.139
返回value

00:09:27.139 --> 00:09:27.899
对不对

00:09:27.899 --> 00:09:29.139
当然返回之前呢

00:09:29.139 --> 00:09:30.179
干嘛

00:09:30.179 --> 00:09:31.600
this.tale

00:09:31.600 --> 00:09:32.259
nace

00:09:32.259 --> 00:09:33.100
减减

00:09:33.100 --> 00:09:34.379
就是记录长度

00:09:34.379 --> 00:09:36.740
这样就完了吗

00:09:36.740 --> 00:09:38.039
当然没有完

00:09:38.039 --> 00:09:38.319
对吧

00:09:38.319 --> 00:09:42.439
你现在只是把这个head的值取出来返回了

00:09:42.439 --> 00:09:44.620
但是还有一步是什么呢

00:09:44.620 --> 00:09:45.699
因为你要出对

00:09:45.700 --> 00:09:48.820
所以说你要把这个head这一块给它断开

00:09:48.820 --> 00:09:51.640
把这个head指向这个地方来

00:09:51.640 --> 00:09:52.840
这一步还没有做

00:09:52.840 --> 00:09:55.680
所以说我们取值完之后

00:09:55.680 --> 00:09:58.520
我们要处理head

00:09:58.519 --> 00:09:59.579
就是

00:09:59.579 --> 00:10:01.659
this.head

00:10:01.659 --> 00:10:02.559
复制成

00:10:02.559 --> 00:10:05.259
当前headnode.next

00:10:05.259 --> 00:10:07.199
就这一步

00:10:07.199 --> 00:10:08.120
这一步就是

00:10:08.120 --> 00:10:09.600
就是让这个

00:10:09.600 --> 00:10:11.419
这个head

00:10:11.419 --> 00:10:13.059
直接指向了下个节点

00:10:13.059 --> 00:10:13.919
这样的话

00:10:13.919 --> 00:10:14.480
这个

00:10:14.480 --> 00:10:16.439
就相当于什么呢

00:10:16.439 --> 00:10:17.059
相当于是

00:10:17.059 --> 00:10:18.860
把这个给它删除了

00:10:18.860 --> 00:10:19.319
对不对

00:10:19.319 --> 00:10:20.319
就这个意思

00:10:20.319 --> 00:10:21.139
好

00:10:21.139 --> 00:10:22.220
所以这一步要很重要

00:10:22.220 --> 00:10:23.720
这是出对啊

00:10:23.720 --> 00:10:24.259
出对

00:10:24.259 --> 00:10:25.860
然后lace

00:10:25.860 --> 00:10:26.779
其实就好说了

00:10:26.779 --> 00:10:28.079
lace我们说

00:10:28.080 --> 00:10:29.980
直接返回this.head

00:10:29.980 --> 00:10:31.480
lace就可以了

00:10:31.480 --> 00:10:33.379
这写一个

00:10:33.379 --> 00:10:34.660
写个注释吧

00:10:34.660 --> 00:10:38.440
lace要

00:10:38.440 --> 00:10:40.440
要单独存储

00:10:40.440 --> 00:10:41.220
不能

00:10:41.220 --> 00:10:43.740
便利

00:10:43.740 --> 00:10:45.940
不能便利

00:10:45.940 --> 00:10:47.759
链表来获取

00:10:47.759 --> 00:10:48.860
否则

00:10:48.860 --> 00:10:50.700
否则时间

00:10:50.700 --> 00:10:52.920
复杂度太高

00:10:52.920 --> 00:10:54.440
就是all in的时间

00:10:54.440 --> 00:10:55.320
就太高了

00:10:55.320 --> 00:10:55.720
对不对

00:10:55.720 --> 00:10:58.020
好

00:10:58.019 --> 00:10:58.600
这样的话

00:10:58.600 --> 00:10:59.240
其实就写完了

00:10:59.240 --> 00:11:00.220
一个add

00:11:00.220 --> 00:11:01.699
一个delete

00:11:01.699 --> 00:11:02.740
一个lace

00:11:02.740 --> 00:11:03.980
我们写单码的过程中

00:11:03.980 --> 00:11:05.120
其实就完全贯彻了

00:11:05.120 --> 00:11:06.100
我们之前想到三点

00:11:06.100 --> 00:11:06.779
第一个

00:11:06.779 --> 00:11:07.539
有head

00:11:07.539 --> 00:11:08.039
有tail

00:11:08.039 --> 00:11:08.879
第二个

00:11:08.879 --> 00:11:10.899
从tail入对

00:11:10.899 --> 00:11:12.740
从head出对

00:11:12.740 --> 00:11:13.819
第三个

00:11:13.819 --> 00:11:16.039
lace要单独存储

00:11:16.039 --> 00:11:18.139
不要便利链表来获取

00:11:18.139 --> 00:11:19.379
这三点

00:11:19.379 --> 00:11:20.419
然后接下来

00:11:20.419 --> 00:11:21.379
我们做功能测试

00:11:21.379 --> 00:11:25.059
好

00:11:25.059 --> 00:11:26.100
先定一个实例

00:11:26.100 --> 00:11:26.559
然后

00:11:26.559 --> 00:11:28.220
quen.add

00:11:28.220 --> 00:11:29.399
100

00:11:29.399 --> 00:11:30.820
quen.add

00:11:30.820 --> 00:11:31.980
200

00:11:31.980 --> 00:11:34.340
quen.add

00:11:34.340 --> 00:11:35.340
300

00:11:35.340 --> 00:11:35.919
对吧

00:11:35.919 --> 00:11:36.939
这个时候

00:11:36.939 --> 00:11:37.939
我们可以去

00:11:37.939 --> 00:11:40.899
console.infer

00:11:40.899 --> 00:11:43.899
lace1

00:11:43.899 --> 00:11:44.480
我们看一下

00:11:44.480 --> 00:11:45.320
它的lace多少

00:11:45.320 --> 00:11:47.120
对吧

00:11:47.120 --> 00:11:48.019
我们说过

00:11:48.019 --> 00:11:48.960
如果说一个方法

00:11:48.960 --> 00:11:49.620
前面加上get

00:11:49.620 --> 00:11:50.940
我们就可以通过

00:11:50.940 --> 00:11:51.820
像属性一样

00:11:51.820 --> 00:11:52.200
调用它

00:11:52.200 --> 00:11:52.879
不用加括号

00:11:52.879 --> 00:11:56.720
然后我们再去

00:11:56.720 --> 00:11:58.100
打印一下

00:11:58.100 --> 00:11:59.360
它删除

00:11:59.360 --> 00:12:00.660
看它删除

00:12:00.660 --> 00:12:01.600
返回的是什么

00:12:01.600 --> 00:12:03.340
这个删除完之后

00:12:03.340 --> 00:12:04.320
我们再打印一遍

00:12:04.320 --> 00:12:04.780
这个lace

00:12:04.780 --> 00:12:05.580
好

00:12:05.580 --> 00:12:06.500
我们再删除

00:12:06.500 --> 00:12:09.060
我们再打印一遍

00:12:09.060 --> 00:12:09.400
lace

00:12:09.400 --> 00:12:11.780
每次这个提示

00:12:11.780 --> 00:12:12.240
提示呢

00:12:12.240 --> 00:12:12.780
我都不一样

00:12:12.780 --> 00:12:13.480
这样的话

00:12:13.480 --> 00:12:14.060
容易辨别

00:12:14.060 --> 00:12:15.360
我们删除这几遍

00:12:15.360 --> 00:12:15.920
我们看看

00:12:15.920 --> 00:12:16.540
效果是怎么样

00:12:16.540 --> 00:12:17.379
保存

00:12:17.379 --> 00:12:19.000
游染器

00:12:19.000 --> 00:12:20.240
刷新

00:12:20.240 --> 00:12:22.080
我们看一下

00:12:22.080 --> 00:12:23.720
当我们加了这个

00:12:23.720 --> 00:12:24.399
100

00:12:24.399 --> 00:12:24.820
200

00:12:24.820 --> 00:12:25.480
300之后

00:12:25.480 --> 00:12:26.480
我们打印的

00:12:26.480 --> 00:12:27.240
这个lace1是多少

00:12:27.240 --> 00:12:28.279
是3

00:12:28.279 --> 00:12:28.700
这个对

00:12:28.700 --> 00:12:29.000
对吧

00:12:29.000 --> 00:12:30.840
然后我们第一次删除

00:12:30.840 --> 00:12:32.200
因为它是先进先出

00:12:32.200 --> 00:12:32.939
所以说

00:12:32.939 --> 00:12:33.840
kning先删100

00:12:33.840 --> 00:12:34.820
第一次删除

00:12:34.820 --> 00:12:36.220
那就是出来是100

00:12:36.220 --> 00:12:36.679
删了100

00:12:36.679 --> 00:12:38.259
然后lace就变成2了

00:12:38.259 --> 00:12:38.980
删了一个

00:12:38.980 --> 00:12:40.720
我们再做第二次删除

00:12:40.720 --> 00:12:42.080
那就出的是这样

00:12:42.080 --> 00:12:42.500
是200

00:12:42.500 --> 00:12:42.980
对吧

00:12:42.980 --> 00:12:43.799
出的是200

00:12:43.799 --> 00:12:45.779
然后lace就变成1了

00:12:45.779 --> 00:12:46.600
对不对

00:12:46.600 --> 00:12:47.600
ok

00:12:47.600 --> 00:12:49.820
我们可以再去实验一遍

00:12:49.820 --> 00:12:51.899
然后再做一遍删除

00:12:51.899 --> 00:12:53.080
单一个lace

00:12:53.080 --> 00:12:54.600
然后再做一遍删除

00:12:54.600 --> 00:12:55.820
删完为止

00:12:55.820 --> 00:12:59.620
第三遍删除

00:12:59.620 --> 00:13:00.639
就删了300

00:13:00.639 --> 00:13:01.600
lace就是0了

00:13:01.600 --> 00:13:02.540
再往下呢

00:13:02.540 --> 00:13:03.019
就是n

00:13:03.019 --> 00:13:04.360
就是没得删了嘛

00:13:04.360 --> 00:13:05.460
没得删返回就是n

00:13:05.460 --> 00:13:07.259
然后lace还是0

00:13:07.259 --> 00:13:07.820
对不对

00:13:07.820 --> 00:13:09.240
我们看一下这个delete

00:13:09.240 --> 00:13:09.779
它返回的

00:13:09.779 --> 00:13:10.500
可是number

00:13:10.500 --> 00:13:11.040
或者是n

00:13:11.040 --> 00:13:12.120
没得删了

00:13:12.120 --> 00:13:12.700
那就返回n

00:13:12.700 --> 00:13:14.820
这符合我们的预期

00:13:14.820 --> 00:13:16.920
我们把这个冷线注释掉

00:13:16.920 --> 00:13:19.000
ok

00:13:19.000 --> 00:13:21.120
功能测试写完了

00:13:21.120 --> 00:13:22.640
还差什么呢

00:13:22.640 --> 00:13:23.960
代元测试

00:13:23.960 --> 00:13:25.000
对吧

00:13:25.000 --> 00:13:25.379
quint

00:13:25.379 --> 00:13:27.379
withlist

00:13:27.379 --> 00:13:28.580
点test

00:13:28.580 --> 00:13:28.600
点test

00:13:28.600 --> 00:13:29.259
点ts

00:13:29.259 --> 00:13:30.000
好

00:13:30.000 --> 00:13:33.620
链表实现

00:13:33.620 --> 00:13:34.379
对列

00:13:34.379 --> 00:13:35.179
test

00:13:35.179 --> 00:13:39.379
ok

00:13:39.379 --> 00:13:42.600
首先我们要从这个代码中

00:13:42.600 --> 00:13:46.139
取出

00:13:46.139 --> 00:13:48.519
这个myquint

00:13:48.519 --> 00:13:49.139
这个class

00:13:49.139 --> 00:13:50.639
然后describe

00:13:50.639 --> 00:13:57.939
那这里面我们去写测试用力

00:13:57.939 --> 00:13:59.419
可以写两个测试用力

00:13:59.419 --> 00:14:00.379
第一个呢

00:14:00.379 --> 00:14:02.000
就是add andlace

00:14:02.000 --> 00:14:03.240
就是我们去添加

00:14:03.240 --> 00:14:05.019
然后去看看它的lace怎么样

00:14:05.019 --> 00:14:07.319
然后定一个new

00:14:07.320 --> 00:14:08.980
myquint

00:14:08.980 --> 00:14:11.060
然后这里面

00:14:11.060 --> 00:14:12.620
首先

00:14:12.620 --> 00:14:13.440
expect

00:14:13.440 --> 00:14:15.260
quint.lace.to

00:14:15.260 --> 00:14:15.720
b

00:14:15.720 --> 00:14:16.280
我们说

00:14:16.280 --> 00:14:18.640
这个普通的直类型的数

00:14:18.640 --> 00:14:20.560
断言是用tob

00:14:20.560 --> 00:14:21.020
对吧

00:14:21.020 --> 00:14:22.020
它是0

00:14:22.020 --> 00:14:23.080
因为一开始嘛

00:14:23.080 --> 00:14:23.600
是0

00:14:23.600 --> 00:14:24.540
是吧

00:14:24.540 --> 00:14:25.440
好

00:14:25.440 --> 00:14:25.900
0

00:14:25.900 --> 00:14:27.300
q.i的

00:14:27.300 --> 00:14:27.860
100

00:14:27.860 --> 00:14:29.540
然后q.i的

00:14:29.540 --> 00:14:30.340
200

00:14:30.340 --> 00:14:31.620
q.i的

00:14:31.620 --> 00:14:32.700
300

00:14:32.700 --> 00:14:34.440
expect

00:14:34.440 --> 00:14:36.020
q.lace

00:14:36.020 --> 00:14:36.640
多少呢

00:14:36.639 --> 00:14:39.259
3

00:14:39.259 --> 00:14:39.960
对吧

00:14:39.960 --> 00:14:40.699
这样没有问题

00:14:40.699 --> 00:14:41.279
是吧

00:14:41.279 --> 00:14:42.519
好

00:14:42.519 --> 00:14:44.199
我们add做了测试了

00:14:44.199 --> 00:14:45.639
我们可以对delete

00:14:45.639 --> 00:14:47.319
再做一个测试

00:14:47.319 --> 00:14:47.919
delete

00:14:47.919 --> 00:14:54.419
然后还是这样

00:14:54.419 --> 00:14:55.819
我们把这个拷贝过来

00:14:55.819 --> 00:14:56.639
然后这个时候

00:14:56.639 --> 00:14:57.980
我们不去测它的这个

00:14:57.980 --> 00:14:59.100
它的list

00:14:59.100 --> 00:15:00.740
我们直接测它的delete

00:15:00.740 --> 00:15:02.259
也就是一开始是空的

00:15:02.259 --> 00:15:03.419
我们直接来delete

00:15:03.419 --> 00:15:04.620
那它是什么呢

00:15:04.620 --> 00:15:05.319
它就是

00:15:05.320 --> 00:15:07.379
有一个新的断言

00:15:07.379 --> 00:15:08.220
叫tob

00:15:08.220 --> 00:15:08.580
nan

00:15:08.580 --> 00:15:10.160
tobnan

00:15:10.160 --> 00:15:11.320
就是说它返回的就是个nan

00:15:11.320 --> 00:15:13.120
这样写就比较方便一些

00:15:13.120 --> 00:15:15.160
也说我们新建一个队列

00:15:15.160 --> 00:15:16.460
它一开始就要删

00:15:16.460 --> 00:15:17.580
它删的肯定是出来

00:15:17.580 --> 00:15:18.260
肯定是个nan

00:15:18.260 --> 00:15:18.540
对吧

00:15:18.540 --> 00:15:21.540
然后我们再加三个元素

00:15:21.540 --> 00:15:22.360
这个时候

00:15:22.360 --> 00:15:23.640
我们再去删

00:15:23.640 --> 00:15:25.100
第一次删除

00:15:25.100 --> 00:15:27.200
它返回的应该是什么

00:15:27.200 --> 00:15:30.100
100

00:15:30.100 --> 00:15:30.320
200

00:15:30.320 --> 00:15:30.520
300

00:15:35.320 --> 00:15:37.020
返回的应该是200

00:15:37.020 --> 00:15:38.680
然后第二次删除

00:15:38.680 --> 00:15:40.460
返回的应该是300

00:15:40.460 --> 00:15:41.900
然后第四次删除

00:15:41.900 --> 00:15:43.320
返回的应该是什么呢

00:15:43.320 --> 00:15:45.160
又是nan

00:15:45.160 --> 00:15:47.760
对不对

00:15:47.760 --> 00:15:49.540
OK

00:15:49.540 --> 00:15:52.360
这样我们检查一下

00:15:52.360 --> 00:15:52.860
100

00:15:52.860 --> 00:15:53.060
200

00:15:53.060 --> 00:15:53.300
300

00:15:53.300 --> 00:15:53.560
100

00:15:53.560 --> 00:15:53.680
200

00:15:53.680 --> 00:15:53.960
300

00:15:53.960 --> 00:15:57.120
我们把这个空拆断开

00:15:57.120 --> 00:15:58.440
然后我们去执行

00:15:58.440 --> 00:16:00.600
删用力

00:16:00.600 --> 00:16:00.960
代码

00:16:00.960 --> 00:16:05.020
回撤

00:16:05.019 --> 00:16:10.679
好

00:16:10.679 --> 00:16:11.279
通过了

00:16:11.279 --> 00:16:11.740
对吧

00:16:11.740 --> 00:16:13.279
OK

00:16:13.279 --> 00:16:14.939
其实啊

00:16:14.939 --> 00:16:15.500
还是能一话

00:16:15.500 --> 00:16:17.860
把这个逻辑搞明白了

00:16:17.860 --> 00:16:19.059
测试代码呢

00:16:19.059 --> 00:16:20.379
其实并不是那么麻烦

00:16:20.379 --> 00:16:21.860
工作测试搞明白了

00:16:21.860 --> 00:16:22.759
单元测试

00:16:22.759 --> 00:16:24.220
其实并不是那么麻烦

00:16:24.220 --> 00:16:26.100
但是我们之前也一直说

00:16:26.100 --> 00:16:27.460
在算法题目中

00:16:27.460 --> 00:16:29.819
如果你能有这种单元测试的思维

00:16:29.819 --> 00:16:31.179
那对你的这个优势来说

00:16:31.179 --> 00:16:32.419
影响非常非常大

00:16:32.419 --> 00:16:33.899
因为绝大部分同学

00:16:33.899 --> 00:16:35.319
在面试的时候

00:16:35.319 --> 00:16:38.019
他是没有这种单元测试的这种思维的

00:16:38.019 --> 00:16:39.659
你像你在面试的时候没有

00:16:39.659 --> 00:16:40.639
你在工作的时候能有吗

00:16:40.639 --> 00:16:41.000
对吧

00:16:41.000 --> 00:16:42.459
那你之前肯定没写过

00:16:42.459 --> 00:16:42.899
没写过

00:16:42.899 --> 00:16:43.980
你写出来肯定手生嘛

00:16:43.980 --> 00:16:44.740
对不对

00:16:44.740 --> 00:16:46.159
对不对

00:16:46.159 --> 00:16:46.740
对不对

00:16:46.740 --> 00:16:47.259
对不对

