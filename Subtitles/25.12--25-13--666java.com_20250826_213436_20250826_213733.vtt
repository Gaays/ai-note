WEBVTT

00:00:00.000 --> 00:00:01.900
好 我们继续啊

00:00:01.900 --> 00:00:03.640
这个题目的本身观众是什么呢

00:00:03.640 --> 00:00:05.339
表面上关注的是

00:00:05.339 --> 00:00:07.780
链表 数组 堆裂这些概念

00:00:07.780 --> 00:00:09.660
其实核心观众的是性能

00:00:09.660 --> 00:00:12.280
也就是说为什么我们要用链表去实现堆裂

00:00:12.280 --> 00:00:14.500
为什么不用数组 数组那么方便

00:00:14.500 --> 00:00:15.880
链表调整的麻烦

00:00:15.880 --> 00:00:16.719
还得这么多概念

00:00:16.719 --> 00:00:17.900
不就为了性能吗

00:00:17.900 --> 00:00:19.980
所以说我们必须要有单独一节

00:00:19.980 --> 00:00:20.920
去专门讲性能

00:00:20.920 --> 00:00:21.800
这个很重要

00:00:21.800 --> 00:00:24.400
大家看我们的题目都有侧重力

00:00:24.400 --> 00:00:25.539
有些是侧重数据结构

00:00:25.539 --> 00:00:26.199
有些是侧重性能

00:00:26.199 --> 00:00:26.839
有些是侧重概念

00:00:26.839 --> 00:00:27.339
对吧

00:00:27.339 --> 00:00:28.060
所以侧重什么地方

00:00:28.060 --> 00:00:29.920
我们就会单独去重点讲什么地方

00:00:29.920 --> 00:00:32.060
这个地方我们前面讲的是

00:00:32.060 --> 00:00:34.940
功能测试对吧

00:00:34.940 --> 00:00:37.180
然后下面我们就是性能测试

00:00:37.180 --> 00:00:41.219
首先我们要定义一个

00:00:41.219 --> 00:00:43.180
通过用链表实现

00:00:43.180 --> 00:00:44.960
就是我们刚才用链表实现的这个对立

00:00:44.960 --> 00:00:46.060
定义一个实例

00:00:46.060 --> 00:00:47.980
然后在这个实例里面呢

00:00:47.980 --> 00:00:50.700
我们去通过时间来计算

00:00:50.700 --> 00:00:52.460
写一个标识

00:00:52.460 --> 00:00:54.400
queen with list

00:00:54.400 --> 00:00:55.480
这是时间的开始

00:00:55.480 --> 00:00:57.079
然后我们再写一个timeend

00:00:57.079 --> 00:00:58.479
代表时间的结束

00:00:58.479 --> 00:01:00.119
然后中间我们就做一个操作

00:01:00.119 --> 00:01:01.079
首先

00:01:01.079 --> 00:01:03.699
我们做一个add的操作

00:01:03.699 --> 00:01:06.200
let's i 复制成零

00:01:06.200 --> 00:01:08.980
i 小于

00:01:08.980 --> 00:01:10.179
我们来十万次

00:01:10.179 --> 00:01:11.480
多少之后才能看出来

00:01:11.480 --> 00:01:12.079
对吧

00:01:12.079 --> 00:01:12.640
十万次

00:01:12.640 --> 00:01:14.039
i 加价

00:01:14.039 --> 00:01:15.039
OK

00:01:15.039 --> 00:01:15.900
这个时候

00:01:15.900 --> 00:01:18.039
queen add

00:01:18.040 --> 00:01:23.500
然后接下来我们再来一个循环

00:01:23.500 --> 00:01:24.560
十万次

00:01:24.560 --> 00:01:27.100
去让它去delete

00:01:27.100 --> 00:01:28.560
当然这个i就不用传了

00:01:28.560 --> 00:01:29.280
对吧

00:01:29.280 --> 00:01:30.440
这是一次测试

00:01:30.440 --> 00:01:33.040
然后我们把这个再拷贝一下

00:01:33.040 --> 00:01:35.640
定一个qr

00:01:35.640 --> 00:01:37.260
是什么呢

00:01:37.260 --> 00:01:38.040
数组啊

00:01:38.040 --> 00:01:38.440
对吧

00:01:38.440 --> 00:01:39.940
数组啊

00:01:39.940 --> 00:01:42.380
这个是测试我们自己用链表实现的对立

00:01:42.380 --> 00:01:43.719
然后这个就是一个数组

00:01:43.719 --> 00:01:46.280
数组就是queen with array

00:01:46.280 --> 00:01:53.019
然后数组我们用pose来去做入对

00:01:53.019 --> 00:01:56.700
入对

00:01:56.700 --> 00:01:59.460
当然这个地方就改成qr了啊

00:01:59.460 --> 00:02:04.379
然后我们用shift来做出对

00:02:04.379 --> 00:02:07.240
OK

00:02:07.240 --> 00:02:08.580
我们保存一下

00:02:08.580 --> 00:02:09.080
看看效果

00:02:09.080 --> 00:02:11.460
重新刷新啊

00:02:12.979 --> 00:02:13.740
大家看一下

00:02:13.740 --> 00:02:15.199
queen with list

00:02:15.199 --> 00:02:16.560
17毫秒

00:02:16.560 --> 00:02:17.959
queen with array

00:02:17.959 --> 00:02:19.599
431毫秒

00:02:19.599 --> 00:02:20.859
我们要记录一下

00:02:20.859 --> 00:02:23.500
这个地方是17毫秒

00:02:23.500 --> 00:02:26.939
这个地方是431毫秒

00:02:26.939 --> 00:02:27.780
大家看一下

00:02:27.780 --> 00:02:31.239
同样的是十万次计算

00:02:31.239 --> 00:02:31.799
对吧

00:02:31.799 --> 00:02:32.719
同样十万次计算

00:02:32.719 --> 00:02:34.560
用链表实现队列

00:02:34.560 --> 00:02:36.139
和用数组相差

00:02:36.139 --> 00:02:37.019
多少倍

00:02:37.019 --> 00:02:37.939
自己算一算

00:02:37.939 --> 00:02:39.620
很多很多倍

00:02:39.620 --> 00:02:40.179
对吧

00:02:40.179 --> 00:02:41.219
这个数据量越大

00:02:41.219 --> 00:02:42.280
相差就越多

00:02:42.280 --> 00:02:43.419
这就是我们说

00:02:43.419 --> 00:02:46.099
为什么用这个链表实现队列

00:02:46.099 --> 00:02:46.800
性能更好一些

00:02:46.800 --> 00:02:48.939
为什么用速度实现更差一些

00:02:48.939 --> 00:02:50.199
这就是一个现象

00:02:50.199 --> 00:02:51.879
当然你自己运行的时候

00:02:51.879 --> 00:02:53.680
它不一定是17和431啊

00:02:53.680 --> 00:02:54.780
那可能不同的情况

00:02:54.780 --> 00:02:56.639
它数值是不一样

00:02:56.639 --> 00:02:58.120
但是它的这个差值

00:02:58.120 --> 00:03:00.120
它这种gap是在这的

00:03:00.120 --> 00:03:01.639
大家可以亲自去试一下

00:03:01.639 --> 00:03:03.020
OK

00:03:03.020 --> 00:03:05.199
有一个形象的一个体会

00:03:05.200 --> 00:03:07.460
这是一个最好的一个理解和学习方式

00:03:07.460 --> 00:03:07.940
对吧

00:03:07.940 --> 00:03:08.600
我光跟你说

00:03:08.600 --> 00:03:09.380
时间法度是多少

00:03:09.380 --> 00:03:10.180
光跟你说

00:03:10.180 --> 00:03:10.780
这个快这个慢

00:03:10.780 --> 00:03:12.400
你自己不去亲自写代码

00:03:12.400 --> 00:03:13.480
自己跑一遍

00:03:13.480 --> 00:03:15.280
你自己是没有这个清晨体会的

00:03:15.280 --> 00:03:16.600
所以说一定要自己去写一遍

00:03:16.600 --> 00:03:17.580
你就意识到

00:03:17.580 --> 00:03:18.440
17和431

00:03:18.440 --> 00:03:20.400
差的还是真的非常非常多的

00:03:20.400 --> 00:03:22.500
所以我们回到pb0来

00:03:22.500 --> 00:03:23.360
现在分析

00:03:23.360 --> 00:03:25.640
空间法度都是on

00:03:25.640 --> 00:03:26.580
我们想一下

00:03:26.580 --> 00:03:27.800
不管是用数组也好

00:03:27.800 --> 00:03:28.940
还是用链表也好

00:03:28.940 --> 00:03:31.200
其实存储的数据都是差不多一样的

00:03:31.200 --> 00:03:32.780
至少这个数量级上都是一样的

00:03:32.780 --> 00:03:34.540
就是你需要输入多少数据

00:03:34.539 --> 00:03:36.000
那我就需要多少空间

00:03:36.000 --> 00:03:36.799
就是on

00:03:36.799 --> 00:03:37.239
对吧

00:03:37.239 --> 00:03:39.120
然后add时间法度

00:03:39.120 --> 00:03:41.000
链表是o1

00:03:41.000 --> 00:03:42.239
数组也是o1

00:03:42.239 --> 00:03:43.759
因为链表嘛

00:03:43.759 --> 00:03:45.000
我们往后面追加一个

00:03:45.000 --> 00:03:46.419
以及数组往后面追加一个

00:03:46.419 --> 00:03:47.979
是不是都是o1级别的

00:03:47.979 --> 00:03:48.840
很快对吧

00:03:48.840 --> 00:03:50.599
但是delete就不一样了

00:03:50.599 --> 00:03:51.799
delete删除的时候

00:03:51.799 --> 00:03:53.259
链表是o1

00:03:53.259 --> 00:03:54.099
数组呢

00:03:54.099 --> 00:03:55.120
就是on

00:03:55.120 --> 00:03:56.739
为什么数组是on呢

00:03:56.739 --> 00:03:59.419
因为数组需要通过shift去出对

00:03:59.419 --> 00:04:00.259
去删除

00:04:00.259 --> 00:04:02.899
这个时候我们之前不止一次的讲过

00:04:02.900 --> 00:04:04.620
数组是一个连续存储结构

00:04:04.620 --> 00:04:06.060
如果用shift出对的话

00:04:06.060 --> 00:04:07.840
后面的数据都需要补上来

00:04:07.840 --> 00:04:09.480
这个时间是非常非常慢的

00:04:09.480 --> 00:04:11.000
它是一个on的实验复杂度

00:04:11.000 --> 00:04:13.060
但是通过链表这两个

00:04:13.060 --> 00:04:14.080
包括我们上面的代码

00:04:14.080 --> 00:04:15.240
大家都可以看出来

00:04:15.240 --> 00:04:16.780
我们没有做任何的循环

00:04:16.780 --> 00:04:18.519
所以说我们的实验复杂度

00:04:18.519 --> 00:04:19.360
永远都是o1

00:04:19.360 --> 00:04:20.699
这是非常非常快

00:04:20.699 --> 00:04:21.960
非常非常理想的一个

00:04:21.960 --> 00:04:22.920
伏杂度的情况

00:04:22.920 --> 00:04:23.620
化妆链

00:04:23.620 --> 00:04:24.860
链表是什么

00:04:24.860 --> 00:04:26.740
以及链表和数组

00:04:26.740 --> 00:04:27.460
它的区别

00:04:27.460 --> 00:04:29.240
特别是在我们本节

00:04:29.240 --> 00:04:30.920
他们两个去实现

00:04:30.920 --> 00:04:32.040
对列上的一个区别

00:04:32.040 --> 00:04:33.319
然后注意

00:04:33.319 --> 00:04:34.540
数据结构的选择

00:04:34.540 --> 00:04:36.420
要比算法优化更重要

00:04:36.420 --> 00:04:37.480
这点我不知道大家

00:04:37.480 --> 00:04:38.300
有没有一个体会

00:04:38.300 --> 00:04:39.160
或者是有没有

00:04:39.160 --> 00:04:40.280
从别的地方听说过

00:04:40.280 --> 00:04:42.540
因为在我们大众印象中

00:04:42.540 --> 00:04:44.259
都说优化

00:04:44.259 --> 00:04:45.939
然后复杂度

00:04:45.939 --> 00:04:46.939
然后性能

00:04:46.939 --> 00:04:48.600
都是和算法有关系的

00:04:48.600 --> 00:04:50.060
我们的算法要做的多好

00:04:50.060 --> 00:04:50.939
做的多精妙

00:04:50.939 --> 00:04:52.480
做的多精致才行

00:04:52.480 --> 00:04:53.520
这个算法多牛

00:04:53.520 --> 00:04:54.220
那个算法多烂

00:04:54.220 --> 00:04:54.640
对吧

00:04:54.640 --> 00:04:56.060
但是好像从来没有人

00:04:56.060 --> 00:04:57.040
去提到过实验

00:04:57.040 --> 00:04:58.500
数据结构的一个重要性

00:04:58.500 --> 00:04:59.700
其实在我看来

00:04:59.700 --> 00:05:01.760
以及大家看完这一章之后

00:05:01.760 --> 00:05:02.760
会有一个很深刻的体会

00:05:02.760 --> 00:05:05.040
就是如果你数据结构选对了

00:05:05.040 --> 00:05:06.360
你的算法再烂

00:05:06.360 --> 00:05:07.400
也烂到哪去

00:05:07.400 --> 00:05:09.140
如果你的数据结构写错了

00:05:09.140 --> 00:05:10.200
你的算法再精妙

00:05:10.200 --> 00:05:11.160
你也精妙到哪去

00:05:11.160 --> 00:05:12.640
就像我们实现一个队列

00:05:12.640 --> 00:05:14.120
用列表和用数组

00:05:14.120 --> 00:05:14.960
这两个结构

00:05:14.960 --> 00:05:16.580
虽然说是两个物理结构

00:05:16.580 --> 00:05:17.060
对吧

00:05:17.060 --> 00:05:19.280
你选择不同的选择链表

00:05:19.280 --> 00:05:20.280
选择速度

00:05:20.280 --> 00:05:21.040
实现队列

00:05:21.040 --> 00:05:22.079
你的算法

00:05:22.079 --> 00:05:23.360
不用做什么优化

00:05:23.360 --> 00:05:24.800
你的整个的实验

00:05:24.800 --> 00:05:25.300
达度上

00:05:25.300 --> 00:05:26.100
整个性能上

00:05:26.100 --> 00:05:26.780
就会差一点的

00:05:26.780 --> 00:05:28.920
所以说数据结构的选择

00:05:28.920 --> 00:05:30.379
是最重要的一个东西

00:05:30.379 --> 00:05:31.660
当然这是在算法上

00:05:31.660 --> 00:05:33.720
其实在我们再往下讲

00:05:33.720 --> 00:05:35.240
在讲到后面章节的时候

00:05:35.240 --> 00:05:37.779
我们在一些系统设计上来说

00:05:37.779 --> 00:05:38.600
数据结构

00:05:38.600 --> 00:05:39.740
以及数据模型的设计

00:05:39.740 --> 00:05:41.879
也是一个至关重要的一个东西

00:05:41.879 --> 00:05:43.199
如果说你的一个

00:05:43.199 --> 00:05:44.340
整个系统设计

00:05:44.340 --> 00:05:45.340
不是一个小算法

00:05:45.340 --> 00:05:46.480
是一个大的系统设计

00:05:46.480 --> 00:05:48.400
数据模型都没有选好

00:05:48.400 --> 00:05:49.300
都没有规划好的话

00:05:49.300 --> 00:05:50.540
扩展性都没有保证的话

00:05:50.540 --> 00:05:51.800
你后面的一些扩展

00:05:51.800 --> 00:05:52.480
一些功能升级

00:05:52.480 --> 00:05:53.680
都是非常非常恶心

00:05:53.680 --> 00:05:55.080
非常非常复杂的一些事情

00:05:55.080 --> 00:05:56.200
我觉得数据结构

00:05:56.200 --> 00:05:57.379
要优于算法

00:05:57.379 --> 00:05:58.180
所以说

00:05:58.180 --> 00:06:00.600
我们在正规的计算机学院

00:06:00.600 --> 00:06:01.980
计算机课程里面

00:06:01.980 --> 00:06:03.200
正规的数据里面

00:06:03.200 --> 00:06:04.379
大家看这个数据的名字

00:06:04.379 --> 00:06:04.800
对啊

00:06:04.800 --> 00:06:06.220
数据结构和算法

00:06:06.220 --> 00:06:08.080
没有数叫算法和数据结构

00:06:08.080 --> 00:06:09.040
没有这么叫的

00:06:09.040 --> 00:06:10.420
都是叫数据结构和算法

00:06:10.420 --> 00:06:11.140
它在前

00:06:11.140 --> 00:06:11.580
它在后

00:06:11.579 --> 00:06:14.659
然后要有时间复杂度的敏感性

00:06:14.659 --> 00:06:15.699
敏感性

00:06:15.699 --> 00:06:17.000
要有这种条件反射

00:06:17.000 --> 00:06:17.819
比如说

00:06:17.819 --> 00:06:18.519
这个lens

00:06:18.519 --> 00:06:20.060
我们不能去便利插照

00:06:20.060 --> 00:06:21.719
我们要去单独存储

00:06:21.719 --> 00:06:23.000
这个我们刚才强调过

00:06:23.000 --> 00:06:23.300
对吧

00:06:23.300 --> 00:06:24.719
这就需要一个敏感性

00:06:24.719 --> 00:06:26.360
就是你当看到一个问题的时候

00:06:26.360 --> 00:06:28.659
你能立马的从脑子中闪现出来

00:06:28.659 --> 00:06:29.699
这是不是有问题

00:06:29.699 --> 00:06:30.599
分析一下

00:06:30.599 --> 00:06:31.319
果然有问题

00:06:31.319 --> 00:06:32.719
然后我们应该怎么解决

00:06:32.720 --> 00:06:34.000
这种敏感性

00:06:34.000 --> 00:06:36.020
是需要你长期训练的

00:06:36.020 --> 00:06:38.660
这也是我们作为一个优秀程序员

00:06:38.660 --> 00:06:41.620
优秀工程师的一个非常好的一个素质

00:06:41.620 --> 00:06:43.500
大家也要注意去培养

00:06:43.500 --> 00:06:45.040
要就刻意训练去培养它

