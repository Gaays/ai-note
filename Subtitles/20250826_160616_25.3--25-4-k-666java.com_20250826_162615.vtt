WEBVTT

00:00:00.000 --> 00:00:01.720
我开始讲第一个题

00:00:01.720 --> 00:00:04.080
将一个数组旋转K步

00:00:04.080 --> 00:00:05.419
认真听啊

00:00:05.419 --> 00:00:07.440
所有的算法题都比较难

00:00:07.440 --> 00:00:08.400
但是呢

00:00:08.400 --> 00:00:09.820
只要你认真听

00:00:09.820 --> 00:00:11.980
我保证每个题都能给你讲明白

00:00:11.980 --> 00:00:13.480
我们慢慢的来慢慢的看

00:00:13.480 --> 00:00:14.099
一步一步走

00:00:14.099 --> 00:00:15.200
先分析题目

00:00:15.200 --> 00:00:17.059
首先输入一个数组

00:00:17.059 --> 00:00:18.199
1234567

00:00:18.199 --> 00:00:20.400
然后让它旋转K步

00:00:20.400 --> 00:00:22.160
假如K等于3的时候呢

00:00:22.160 --> 00:00:23.440
就旋转三步

00:00:23.440 --> 00:00:25.260
旋转三步之后出来什么效果呢

00:00:25.260 --> 00:00:27.719
是5671234

00:00:27.719 --> 00:00:29.359
我们说这个题的意思呢

00:00:29.359 --> 00:00:30.219
是旋转

00:00:30.219 --> 00:00:31.759
就是旋转第一步的时候呢

00:00:31.759 --> 00:00:33.820
是把这个7拿过来

00:00:33.820 --> 00:00:34.939
放在1的前面

00:00:34.939 --> 00:00:36.100
放在最前面

00:00:36.100 --> 00:00:37.560
然后旋转第二步的时候呢

00:00:37.560 --> 00:00:39.259
就把6拿过来再放最前面

00:00:39.259 --> 00:00:41.079
然后再把5拿过来放最前面

00:00:41.079 --> 00:00:41.939
这个旋转离三步

00:00:41.939 --> 00:00:42.740
这样的话

00:00:42.740 --> 00:00:45.500
得到的结果就是5671234

00:00:45.500 --> 00:00:47.260
所以说大家拿到这个题目之后呢

00:00:47.260 --> 00:00:49.799
应该会有一个思路怎么去做

00:00:49.799 --> 00:00:50.960
一般情况下呢

00:00:50.960 --> 00:00:52.539
我们会有两个思路啊

00:00:52.539 --> 00:00:53.140
第一个思路呢

00:00:53.140 --> 00:00:54.879
就是把末尾的元素

00:00:54.879 --> 00:00:56.060
挨个pop

00:00:56.060 --> 00:00:59.460
然后anshift到数族最前面去

00:00:59.460 --> 00:01:00.580
这是第一个思路

00:01:00.580 --> 00:01:01.700
第二个思路呢

00:01:01.700 --> 00:01:03.600
就是把数族做一个拆分

00:01:03.600 --> 00:01:04.460
然后呢

00:01:04.460 --> 00:01:06.540
通过concat给它拼击到一起

00:01:06.540 --> 00:01:09.140
我们可以简单的画一下这两个思路啊

00:01:09.140 --> 00:01:11.799
比如说我们现在有一个数族啊

00:01:11.799 --> 00:01:16.079
1234567

00:01:16.079 --> 00:01:16.840
好

00:01:16.840 --> 00:01:17.520
这是一个数族

00:01:17.520 --> 00:01:19.240
第一种思路就是

00:01:19.239 --> 00:01:22.239
我们把末尾的元素给它做pop

00:01:22.239 --> 00:01:23.119
然后呢

00:01:23.119 --> 00:01:26.140
在前面给它anshift插到前面去

00:01:26.140 --> 00:01:27.640
比如说旋转第一步

00:01:27.640 --> 00:01:29.640
就把这个7pop出来

00:01:29.640 --> 00:01:31.199
然后把它7放在这儿来

00:01:31.199 --> 00:01:32.280
第二步的时候呢

00:01:32.280 --> 00:01:33.259
把6pop出来

00:01:33.259 --> 00:01:35.679
然后把6放在这个地方前面来

00:01:35.679 --> 00:01:36.840
然后第三步的时候

00:01:36.840 --> 00:01:37.699
把5pop出来

00:01:37.699 --> 00:01:39.780
然后把5放在这个最前面来

00:01:39.780 --> 00:01:40.579
这样的话

00:01:40.579 --> 00:01:42.519
我们把这个地方删掉

00:01:42.519 --> 00:01:43.579
然后在这儿加个多块

00:01:43.579 --> 00:01:46.159
就是5671234

00:01:46.159 --> 00:01:47.399
这是第一种思路

00:01:47.399 --> 00:01:48.599
那第二种思路呢

00:01:48.600 --> 00:01:53.600
就是1234567

00:01:53.600 --> 00:01:54.380
一个数族

00:01:54.380 --> 00:01:57.940
然后我们要旋转k等于3

00:01:57.940 --> 00:01:58.820
旋转三步对吧

00:01:58.820 --> 00:02:00.960
然后我们就把后面这三个

00:02:00.960 --> 00:02:02.100
单独拆出来

00:02:02.100 --> 00:02:04.940
拆出来就是567

00:02:04.940 --> 00:02:07.300
然后在前面这几个拆出来

00:02:07.300 --> 00:02:10.800
就是1234

00:02:10.800 --> 00:02:13.360
然后最后把它们拼接在一起

00:02:13.360 --> 00:02:14.540
出来这么一个结果

00:02:14.540 --> 00:02:16.080
5671234

00:02:16.080 --> 00:02:17.100
大家注意

00:02:17.100 --> 00:02:18.520
这是第一种思路

00:02:18.599 --> 00:02:19.599
这是第二种思路

00:02:19.599 --> 00:02:21.139
第一种思路的好处呢

00:02:21.139 --> 00:02:23.319
就是他没有动这个数族

00:02:23.319 --> 00:02:25.939
就在这个本身的数族上进行操作

00:02:25.939 --> 00:02:27.299
把最后一个删掉

00:02:27.299 --> 00:02:28.740
拿到前面来

00:02:28.740 --> 00:02:29.639
这样做的

00:02:29.639 --> 00:02:30.560
第二步呢

00:02:30.560 --> 00:02:33.240
是我直接取出这部分

00:02:33.240 --> 00:02:34.400
然后这部分

00:02:34.400 --> 00:02:39.400
生成了一个生成了一个新的数族

00:02:39.400 --> 00:02:41.659
或者说生成了两个新的数族

00:02:41.659 --> 00:02:42.840
这个和这个

00:02:42.840 --> 00:02:43.439
最后呢

00:02:43.439 --> 00:02:44.800
再拼接出来

00:02:44.800 --> 00:02:45.620
然后再返回

00:02:45.620 --> 00:02:46.980
这是这两种思路

00:02:46.980 --> 00:02:48.540
这两种思路哪个好呢

00:02:48.540 --> 00:02:50.300
你可能说都行啊

00:02:50.300 --> 00:02:50.920
这不都对吗

00:02:50.920 --> 00:02:51.400
对

00:02:51.400 --> 00:02:52.219
是都对

00:02:52.219 --> 00:02:53.420
但我们之前说过

00:02:53.420 --> 00:02:55.680
我们要求最优解

00:02:55.680 --> 00:02:57.560
就是功能是一样的

00:02:57.560 --> 00:03:00.200
但是哪个的算法更优一些

00:03:00.200 --> 00:03:03.200
我们说前端是重时间轻空间

00:03:03.200 --> 00:03:06.460
哪个的时间复杂度会更好一些

00:03:06.460 --> 00:03:09.260
或者说哪个的时间复杂度

00:03:09.260 --> 00:03:11.360
结合空间复杂度更好一些

00:03:11.360 --> 00:03:13.600
因为时间复杂度的权重更高一些

00:03:13.599 --> 00:03:15.979
而空间复杂度的权重稍微低一些

00:03:15.979 --> 00:03:17.340
在我们前段来说

00:03:17.340 --> 00:03:18.219
所以说

00:03:18.219 --> 00:03:19.259
我们就研究一下

00:03:19.259 --> 00:03:19.939
这两个

00:03:19.939 --> 00:03:21.599
我们到底要取哪个

00:03:21.599 --> 00:03:22.699
这是重点

00:03:22.699 --> 00:03:24.579
好

00:03:24.579 --> 00:03:25.299
接下来代码演示

00:03:25.299 --> 00:03:26.379
他们演示

00:03:26.379 --> 00:03:28.120
我们直接新建了一个代码

00:03:28.120 --> 00:03:31.400
叫arraylutist.ts

00:03:31.400 --> 00:03:33.599
我们这个代码都是用ts写的

00:03:33.599 --> 00:03:34.699
只要是能用ts写

00:03:34.699 --> 00:03:35.560
我们就用ts写

00:03:35.560 --> 00:03:37.939
这个ts的这个语法呢

00:03:37.939 --> 00:03:39.359
我们会在一边写

00:03:39.359 --> 00:03:40.180
给大家一边介绍

00:03:40.180 --> 00:03:41.400
其实没有那么麻烦

00:03:41.400 --> 00:03:42.560
建完这个之后呢

00:03:42.560 --> 00:03:44.319
我们直接去引用到这个

00:03:44.319 --> 00:03:45.840
把这个注释了吧

00:03:45.840 --> 00:03:48.000
直接引用到这个index这里面来

00:03:48.000 --> 00:03:49.539
import

00:03:49.539 --> 00:03:53.199
把这个引过来

00:03:53.199 --> 00:03:54.280
引过来之后呢

00:03:54.280 --> 00:03:56.460
我们直接去执行这个

00:03:56.460 --> 00:03:58.240
yandev就可以了

00:03:58.240 --> 00:03:59.759
这个代码大家看不出来

00:03:59.759 --> 00:04:00.420
但是没有关系

00:04:00.420 --> 00:04:03.060
我执行的是yandev

00:04:03.060 --> 00:04:04.039
好

00:04:04.039 --> 00:04:05.920
执行完之后

00:04:05.920 --> 00:04:06.819
它会打包

00:04:06.819 --> 00:04:07.780
打包之后呢

00:04:07.780 --> 00:04:09.120
我们可以在这个

00:04:09.120 --> 00:04:11.379
它的结果中去找到这个地址

00:04:11.379 --> 00:04:12.500
就是logohost

00:04:12.500 --> 00:04:14.259
3000这个地址

00:04:14.259 --> 00:04:15.319
我们一刷新

00:04:15.319 --> 00:04:16.639
就能看到这个效果

00:04:16.639 --> 00:04:19.519
然后我们可以把这个浏览器稍微放大一些

00:04:19.519 --> 00:04:21.899
把这个控制台也稍微放大一些

00:04:21.899 --> 00:04:23.139
其实放不放大都行

00:04:23.139 --> 00:04:25.779
OK

00:04:25.779 --> 00:04:27.319
然后这个代码环境呢

00:04:27.319 --> 00:04:29.439
大家可以从我们课程的原代码下载

00:04:29.439 --> 00:04:30.779
这个环境怎么去配置

00:04:30.780 --> 00:04:31.780
我们就不说了

00:04:31.780 --> 00:04:33.540
里面反正就是安装了很多的

00:04:33.540 --> 00:04:36.000
我们ts的编译的一些工具

00:04:36.000 --> 00:04:36.980
但是这个呢

00:04:36.980 --> 00:04:37.840
不是我们课程的重点

00:04:37.840 --> 00:04:39.580
所以说这个大家就拿来就用行了

00:04:39.580 --> 00:04:42.580
我们直接去看这个原码是怎么写的

00:04:42.580 --> 00:04:43.740
关掉这个index

00:04:43.740 --> 00:04:44.800
我们就在这里面写

00:04:44.800 --> 00:04:46.920
然后我们说我们要实现两种思路

00:04:46.920 --> 00:04:47.200
对吧

00:04:47.200 --> 00:04:49.160
接下来我们就先实现第一种思路

00:04:49.160 --> 00:04:50.300
function

00:04:50.300 --> 00:04:52.760
route it 1

00:04:52.759 --> 00:04:53.659
我们叫route it 1

00:04:53.659 --> 00:04:57.279
然后我们输入一个number类型的数组

00:04:57.279 --> 00:04:59.500
然后再输入一个key

00:04:59.500 --> 00:05:01.019
key也是等于number对吧

00:05:01.019 --> 00:05:02.000
最后呢

00:05:02.000 --> 00:05:06.019
我们返回一个number类型的数组

00:05:06.019 --> 00:05:08.120
大家看这个函数啊

00:05:08.120 --> 00:05:10.639
这块是新增的表示参数类型

00:05:10.639 --> 00:05:13.079
就这个array是一个number类型的数组

00:05:13.079 --> 00:05:14.980
number然后加一个这个括号

00:05:14.980 --> 00:05:16.480
就number类型的数组

00:05:16.480 --> 00:05:17.860
然后key呢是一个number类型

00:05:17.860 --> 00:05:21.159
最后我们这个我们函数要返回一个什么呢

00:05:21.159 --> 00:05:22.620
要返回一个number类型的数组

00:05:22.759 --> 00:05:24.879
这就是我们ts里面的一些类型要求

00:05:24.879 --> 00:05:26.199
他的语法是这么写的

00:05:26.199 --> 00:05:27.480
大家跟你说我这么写就行

00:05:27.480 --> 00:05:29.000
但你如果写gs呢

00:05:29.000 --> 00:05:30.959
那你就可以把这块删掉

00:05:30.959 --> 00:05:32.079
把这块删掉

00:05:32.079 --> 00:05:34.120
然后把这块删掉就可以了

00:05:34.120 --> 00:05:35.939
这会有一个报错

00:05:35.939 --> 00:05:36.659
为什么呢

00:05:36.659 --> 00:05:38.740
因为我们这个地方还没有写返回

00:05:38.740 --> 00:05:40.839
所以说他认为我们这个函数呢

00:05:40.839 --> 00:05:42.019
没有任何返回

00:05:42.019 --> 00:05:44.599
不符合这个返回number类型数组的这个要求

00:05:44.599 --> 00:05:45.699
所以说他会报错

00:05:45.699 --> 00:05:46.800
等我们写完之后呢

00:05:46.800 --> 00:05:47.620
他就不会报错了

00:05:47.620 --> 00:05:50.560
我们先找到这个数组的一个lens

00:05:50.560 --> 00:05:53.579
然后我们去判断一下

00:05:53.579 --> 00:05:55.600
如果说这个k

00:05:55.600 --> 00:05:57.399
就是这个k没有值

00:05:57.399 --> 00:06:00.560
或者说这个lens等于0

00:06:00.560 --> 00:06:01.939
也就是数组是空的

00:06:01.939 --> 00:06:04.680
然后我们就直接返回这个数组就可以了

00:06:04.680 --> 00:06:06.620
这是我们判断一个意外情况

00:06:06.620 --> 00:06:06.939
对吧

00:06:06.939 --> 00:06:07.939
接下来呢

00:06:07.939 --> 00:06:09.220
我们就取一个

00:06:09.220 --> 00:06:10.300
他要移动多少步

00:06:10.300 --> 00:06:12.100
我们说是移动k步

00:06:12.100 --> 00:06:13.459
但是这个k啊

00:06:13.459 --> 00:06:14.860
有可能是一个负数

00:06:14.860 --> 00:06:16.800
或者有可能比这个lens要大

00:06:16.800 --> 00:06:17.819
所以说呢

00:06:17.819 --> 00:06:20.660
我们要做一个简单的一个计算

00:06:20.660 --> 00:06:22.500
就是我们通过这个ABS算数

00:06:22.500 --> 00:06:23.780
ABS算数呢

00:06:23.780 --> 00:06:26.040
其实就是取那个取余

00:06:26.040 --> 00:06:27.699
取余是什么意思呢

00:06:27.699 --> 00:06:29.139
就是输入1得1

00:06:29.139 --> 00:06:30.420
输入负1还是得1

00:06:30.420 --> 00:06:31.540
抱歉

00:06:31.540 --> 00:06:32.360
这不是取余

00:06:32.360 --> 00:06:36.139
应该是ABS是取绝对值

00:06:36.139 --> 00:06:37.080
绝对值

00:06:37.080 --> 00:06:37.860
刚才说错了

00:06:37.860 --> 00:06:38.800
取绝对值

00:06:38.800 --> 00:06:40.480
就是如果是1就得1

00:06:40.480 --> 00:06:41.319
如果是负1呢

00:06:41.319 --> 00:06:42.160
他还是返回1

00:06:42.160 --> 00:06:42.580
绝对值

00:06:42.580 --> 00:06:44.960
保证这个step永远是一个正数

00:06:44.960 --> 00:06:48.060
然后这里面我们把这个k取余

00:06:48.060 --> 00:06:49.200
lens

00:06:49.200 --> 00:06:50.220
这是取余

00:06:50.220 --> 00:06:51.400
刚才说换了

00:06:51.400 --> 00:06:52.200
这是取余

00:06:52.200 --> 00:06:55.160
然后如果说这个k要长余lens的话

00:06:55.160 --> 00:06:57.780
这个时候我们也能正确的识别出结果

00:06:57.780 --> 00:06:58.920
但一般情况下

00:06:58.920 --> 00:07:00.120
这一步不会出现

00:07:00.120 --> 00:07:00.760
对吧

00:07:00.760 --> 00:07:04.480
然后接下来我们就去做一个循环

00:07:04.480 --> 00:07:05.960
let i

00:07:05.960 --> 00:07:07.840
复制成0

00:07:07.840 --> 00:07:09.160
i

00:07:09.160 --> 00:07:09.900
小于

00:07:09.900 --> 00:07:10.880
step

00:07:10.880 --> 00:07:11.680
然后

00:07:11.680 --> 00:07:13.220
i

00:07:13.220 --> 00:07:13.960
加加

00:07:13.960 --> 00:07:15.280
大家看

00:07:15.280 --> 00:07:16.900
如果有一步循环

00:07:16.900 --> 00:07:18.340
我们说这个时间反度

00:07:18.340 --> 00:07:19.420
我们之前说过

00:07:19.420 --> 00:07:21.360
至少是一个on级别

00:07:21.360 --> 00:07:21.860
对吧

00:07:21.860 --> 00:07:22.820
这是有一步

00:07:22.820 --> 00:07:24.240
当然里面是怎么样的

00:07:24.240 --> 00:07:24.680
我们不知道

00:07:24.680 --> 00:07:26.880
但只要有一步这个便利

00:07:26.880 --> 00:07:29.700
他这个时间反度就是一个on级别

00:07:29.700 --> 00:07:31.520
我们先在这提醒一下

00:07:31.520 --> 00:07:35.400
然后我们把这个数组进行pop

00:07:35.400 --> 00:07:37.640
也就是说他移动几步

00:07:37.640 --> 00:07:38.720
我们就pop几次

00:07:38.720 --> 00:07:40.080
他移动三步

00:07:40.080 --> 00:07:42.080
我们就把最后这三个全部pop出来

00:07:42.080 --> 00:07:44.780
如果pop的值有值的话

00:07:44.780 --> 00:07:46.840
这个地方应该是不等于non

00:07:46.840 --> 00:07:49.160
因为他有可能是0对吧

00:07:49.160 --> 00:07:51.940
然后array.unshift

00:07:51.940 --> 00:07:55.180
它还有个number的判断

00:07:55.180 --> 00:07:56.020
没关系

00:07:56.020 --> 00:07:57.620
我们可以这么写

00:07:57.620 --> 00:07:59.160
我们先不管0的情况

00:07:59.160 --> 00:08:01.540
然后让他先把代码留声跑完

00:08:01.540 --> 00:08:02.620
也就是说

00:08:02.620 --> 00:08:04.860
如果我们这个step

00:08:04.860 --> 00:08:07.240
比如说是三步也好

00:08:07.240 --> 00:08:07.880
四步也好

00:08:07.880 --> 00:08:09.480
然后我们就便利几步

00:08:09.480 --> 00:08:11.240
就把这个pop出来

00:08:11.240 --> 00:08:13.320
然后放在这个数组的前面

00:08:13.320 --> 00:08:15.780
其实就是跟我们画的这个一样的

00:08:15.780 --> 00:08:17.560
比如说我们step是

00:08:17.560 --> 00:08:19.460
当时的那个step是三

00:08:19.460 --> 00:08:21.020
也就是说k等于三

00:08:21.020 --> 00:08:23.360
它的话就是把后面这三个

00:08:23.360 --> 00:08:24.860
全部pop出来

00:08:24.860 --> 00:08:26.600
然后unshift到前面去

00:08:26.600 --> 00:08:27.580
是这样的

00:08:27.580 --> 00:08:28.500
好

00:08:28.500 --> 00:08:31.340
然后我们再去return

00:08:31.340 --> 00:08:31.880
array

00:08:31.880 --> 00:08:33.019
这样就可以了

00:08:33.019 --> 00:08:35.940
保存这个地方便已经成功了

00:08:35.940 --> 00:08:36.899
是绿色的

00:08:36.899 --> 00:08:39.960
这个其实就是我们刚刚说的那个第一步

00:08:39.960 --> 00:08:42.420
也就是说我们把最后的这几个pop出来

00:08:42.420 --> 00:08:43.879
然后unshift到前面去

00:08:43.879 --> 00:08:47.820
然后我们进行一个功能测试

00:08:47.820 --> 00:08:48.539
我们

00:08:48.539 --> 00:08:50.500
这写个注释

00:08:50.500 --> 00:08:52.740
功能测试

00:08:52.740 --> 00:08:54.299
constarray

00:08:54.299 --> 00:08:54.820
复制成

00:08:54.820 --> 00:08:58.240
1234567

00:08:58.240 --> 00:09:01.500
然后constarray

00:09:01.500 --> 00:09:02.220
1复制成

00:09:02.220 --> 00:09:03.840
rotate1

00:09:03.840 --> 00:09:05.240
然后把这个array挪过去

00:09:05.240 --> 00:09:06.879
然后把3传进去

00:09:06.879 --> 00:09:08.159
要移动三步

00:09:08.159 --> 00:09:10.659
最后我们console log

00:09:10.659 --> 00:09:12.059
console infer

00:09:12.060 --> 00:09:12.620
也可以

00:09:12.620 --> 00:09:14.520
然后array1

00:09:14.520 --> 00:09:15.500
保存

00:09:15.500 --> 00:09:18.120
保存这个时候我们的网页就已经刷新了

00:09:18.120 --> 00:09:19.420
我们看一下

00:09:19.420 --> 00:09:21.160
它的结果是567

00:09:21.160 --> 00:09:22.200
1234

00:09:22.200 --> 00:09:24.320
是不是跟我们的语气是一样的

00:09:24.320 --> 00:09:27.400
这个其实就是我们的第一个思路

00:09:27.400 --> 00:09:28.800
就是pop出来

00:09:28.800 --> 00:09:30.040
然后unshift到前面去

00:09:30.040 --> 00:09:32.460
我们再看我们的第二个思路

00:09:32.460 --> 00:09:36.160
rotate2

00:09:36.160 --> 00:09:37.260
一样的

00:09:37.260 --> 00:09:38.700
我们这个数组呢

00:09:38.700 --> 00:09:41.000
也是一个number类型的数组

00:09:41.000 --> 00:09:43.800
然后k也是一个number的一个数字

00:09:43.800 --> 00:09:44.700
最后呢

00:09:44.700 --> 00:09:48.960
也是返回一个number类型的一个数组

00:09:48.960 --> 00:09:49.360
对不对

00:09:49.360 --> 00:09:51.740
跟这个函数的格式是一样的

00:09:51.740 --> 00:09:52.360
按照规范呢

00:09:52.360 --> 00:09:53.900
其实我们这应该写这个函数注释

00:09:53.899 --> 00:09:56.179
比如说这个是数组

00:09:56.179 --> 00:09:57.819
然后key return

00:09:57.819 --> 00:09:59.379
也是一个数组

00:09:59.379 --> 00:10:01.980
然后这是旋转数组

00:10:01.980 --> 00:10:03.159
key

00:10:03.159 --> 00:10:03.639
不

00:10:03.639 --> 00:10:04.559
为了区分呢

00:10:04.559 --> 00:10:09.139
我们可以加一个使用pop和unshift

00:10:09.139 --> 00:10:10.259
ok

00:10:10.259 --> 00:10:11.740
这也是啊

00:10:11.740 --> 00:10:12.899
我们加一个函数注释

00:10:12.899 --> 00:10:14.179
数组

00:10:14.179 --> 00:10:14.919
然后key

00:10:14.919 --> 00:10:17.139
然后旋转数组

00:10:17.139 --> 00:10:17.779
key

00:10:17.779 --> 00:10:18.460
不

00:10:18.460 --> 00:10:20.699
使用什么呢

00:10:20.699 --> 00:10:21.399
concate

00:10:21.399 --> 00:10:24.600
然后接下来我们就使用第二种思路

00:10:24.600 --> 00:10:25.740
第二种思路呢

00:10:25.740 --> 00:10:27.360
其实前面的判断和之前是一样的

00:10:27.360 --> 00:10:29.019
我们直接拷贝过来

00:10:29.019 --> 00:10:31.159
就验证一下这个lens和这个key

00:10:31.159 --> 00:10:32.699
是不是合法的情况

00:10:32.699 --> 00:10:34.860
以及我们通过这个key取余lens

00:10:34.860 --> 00:10:35.759
然后取余对值呢

00:10:35.759 --> 00:10:36.600
到这个step

00:10:36.600 --> 00:10:39.980
然后接下来我们就去写一下

00:10:39.980 --> 00:10:40.899
part1

00:10:40.899 --> 00:10:43.539
然后我们把这个数组进行slice

00:10:43.539 --> 00:10:44.899
slice

00:10:44.899 --> 00:10:46.399
fullstep

00:10:46.399 --> 00:10:48.199
fullstep什么意思呢

00:10:48.199 --> 00:10:50.059
比如说step如果等于3的话

00:10:50.059 --> 00:10:51.379
这个地方就是-3对吧

00:10:51.399 --> 00:10:53.399
slice-3是什么意思呢

00:10:53.399 --> 00:10:55.299
这个我们可以做一个小测试啊

00:10:55.299 --> 00:10:56.240
在这里面

00:10:56.240 --> 00:11:01.159
比如说我们定义的一个数组是1234

00:11:01.159 --> 00:11:05.159
然后数组.slice-2

00:11:05.159 --> 00:11:06.699
大家看-2取的是什么呢

00:11:06.699 --> 00:11:07.740
是3和4

00:11:07.740 --> 00:11:10.740
要说把最后的几步给它拆完出来

00:11:10.740 --> 00:11:12.939
这就是这个负数的一个意思

00:11:12.939 --> 00:11:15.059
这个意思其实就是跟我们画的

00:11:15.059 --> 00:11:18.059
把这个567这个单独拆出来都是一个数组

00:11:18.060 --> 00:11:18.760
我们继续

00:11:18.760 --> 00:11:20.060
然后这是part1

00:11:20.060 --> 00:11:24.620
part2呢是array.slice

00:11:24.620 --> 00:11:26.820
然后0

00:11:26.820 --> 00:11:29.680
lens-去step

00:11:29.680 --> 00:11:31.820
lens-step

00:11:31.820 --> 00:11:32.060
lens-step

00:11:32.060 --> 00:11:34.600
这个的意思呢

00:11:34.600 --> 00:11:36.680
就是取出前面的1234

00:11:36.680 --> 00:11:38.680
也就是说去掉最后三位

00:11:38.680 --> 00:11:40.160
取出前面的1234

00:11:40.160 --> 00:11:41.260
这个作为一个数组

00:11:41.260 --> 00:11:42.640
也可以试一下

00:11:42.640 --> 00:11:43.820
array.slice

00:11:43.820 --> 00:11:45.100
从0开始

00:11:45.100 --> 00:11:46.120
比如说我们取三位

00:11:46.120 --> 00:11:47.400
取的是什么呢

00:11:47.400 --> 00:11:48.760
这个数组对吧

00:11:48.760 --> 00:11:49.980
取的是123

00:11:49.980 --> 00:11:52.000
ok

00:11:52.000 --> 00:11:52.900
最后呢

00:11:52.900 --> 00:11:56.540
我们去定义这个part3

00:11:56.540 --> 00:11:59.740
复制成part1.contact

00:11:59.740 --> 00:12:01.600
part2

00:12:01.600 --> 00:12:04.640
最后returnpart3

00:12:04.640 --> 00:12:06.700
这是我们的routed2

00:12:06.700 --> 00:12:07.260
对吧

00:12:07.260 --> 00:12:09.360
写完之后呢

00:12:09.360 --> 00:12:10.500
我们就直接进行一个测试

00:12:10.500 --> 00:12:11.580
这个测试很简单

00:12:11.580 --> 00:12:13.760
把这个routed1改成routed2就可以了

00:12:13.820 --> 00:12:14.820
然后保存

00:12:14.820 --> 00:12:15.620
看一下

00:12:15.620 --> 00:12:16.940
刷新

00:12:16.940 --> 00:12:18.680
依然是567

00:12:18.680 --> 00:12:19.520
1234

00:12:19.520 --> 00:12:25.360
那这个写完之后

00:12:25.360 --> 00:12:26.620
我们要干嘛呢

00:12:26.620 --> 00:12:28.460
我们要去对比这两个

00:12:28.460 --> 00:12:29.180
到底哪个好

00:12:29.180 --> 00:12:29.440
对吧

00:12:29.440 --> 00:12:30.800
比如说你是面试官

00:12:30.800 --> 00:12:32.300
有一个同学答了是这个方法

00:12:32.300 --> 00:12:34.140
有一个同学答了是第二个方法

00:12:34.140 --> 00:12:35.840
然后另外一个同学说呢

00:12:35.840 --> 00:12:36.960
那这两个方法都行

00:12:36.960 --> 00:12:37.660
哪个都可以

00:12:37.660 --> 00:12:39.500
有的是他们的答案哪个好呢

00:12:39.500 --> 00:12:40.460
不知道是吧

00:12:40.460 --> 00:12:41.600
解决这个问题之前呢

00:12:41.600 --> 00:12:43.320
我们先把代码的问题

00:12:43.320 --> 00:12:45.400
我们先再做一步

00:12:45.400 --> 00:12:47.160
就是我们要做什么呢

00:12:47.160 --> 00:12:48.920
我们要做单元测试

00:12:48.920 --> 00:12:50.340
大家注意哈

00:12:50.340 --> 00:12:51.900
单元测试这个很重要

00:12:51.900 --> 00:12:53.180
我先写完再说

00:12:53.180 --> 00:12:54.560
我们新建一个文件

00:12:54.560 --> 00:12:56.320
叫array

00:12:56.320 --> 00:13:00.240
rotate.test.ts

00:13:00.240 --> 00:13:04.700
写一个注释

00:13:04.700 --> 00:13:06.160
这个代码格式

00:13:06.160 --> 00:13:07.040
代码规范也很重要

00:13:07.040 --> 00:13:08.980
你在工作的时候

00:13:08.980 --> 00:13:11.740
一定要按照我这种方式来去写

00:13:11.740 --> 00:13:13.220
ok

00:13:13.220 --> 00:13:14.240
代码测试呢

00:13:14.240 --> 00:13:15.420
我们是通过gest

00:13:15.420 --> 00:13:17.539
就是我们安装的这个

00:13:17.539 --> 00:13:18.879
搜一下

00:13:18.879 --> 00:13:19.860
gest

00:13:19.860 --> 00:13:21.440
这个工具来去写的

00:13:21.440 --> 00:13:23.100
那这个工具来写的

00:13:23.100 --> 00:13:24.039
这个代码测试

00:13:24.039 --> 00:13:25.159
你如果没有接触过呢

00:13:25.159 --> 00:13:26.759
你可以简单的去查一下

00:13:26.759 --> 00:13:27.879
我们这直接写

00:13:27.879 --> 00:13:28.800
我一边写了

00:13:28.800 --> 00:13:29.960
一边跟大家去解释

00:13:29.960 --> 00:13:31.460
你用我这个环境

00:13:31.460 --> 00:13:32.800
安装完之后去执行

00:13:32.800 --> 00:13:34.460
也是可以没有问题的

00:13:34.460 --> 00:13:35.540
所以说我们这儿呢

00:13:35.540 --> 00:13:36.680
就不单独去那个

00:13:36.680 --> 00:13:38.620
不单独去学习gest了

00:13:38.620 --> 00:13:39.759
我这儿一边写了

00:13:39.759 --> 00:13:40.240
一边解释

00:13:40.240 --> 00:13:41.580
我保证你能听明白

00:13:41.580 --> 00:13:44.280
首先我们先把之前写的那两个

00:13:44.280 --> 00:13:45.580
先把这个工具测试删掉

00:13:45.580 --> 00:13:47.440
注释掉

00:13:47.440 --> 00:13:48.980
把之前写的那两个呢

00:13:48.980 --> 00:13:50.300
通过expos的方式

00:13:50.300 --> 00:13:51.420
给它导出出来

00:13:51.420 --> 00:13:51.800
要不然的话

00:13:51.800 --> 00:13:52.420
我们没法测

00:13:52.420 --> 00:13:53.960
有时候我们测一下

00:13:53.960 --> 00:13:55.200
这两个数据到底行不行

00:13:55.200 --> 00:13:57.379
保存一下

00:13:57.379 --> 00:13:59.940
然后我们先在这个test

00:13:59.940 --> 00:14:01.420
这个.test.ts

00:14:01.420 --> 00:14:02.160
这个文件里面呢

00:14:02.160 --> 00:14:04.400
我们先去引用这两个

00:14:04.460 --> 00:14:07.280
一个叫routed1

00:14:07.280 --> 00:14:08.960
一个叫routed2

00:14:08.960 --> 00:14:10.000
单元测试的文件

00:14:10.000 --> 00:14:10.680
一般情况下

00:14:10.680 --> 00:14:12.600
开始是通过describe开始的

00:14:12.600 --> 00:14:15.440
就是描述一个测试用力的一个组

00:14:15.440 --> 00:14:18.060
然后我们就写数组旋转

00:14:18.060 --> 00:14:18.920
就是这个是干嘛

00:14:18.920 --> 00:14:21.460
这个测试到底是一个什么描述

00:14:21.460 --> 00:14:22.940
然后后面是一个函数

00:14:22.940 --> 00:14:24.100
这是单元测试

00:14:24.100 --> 00:14:25.420
写单元测试的一个开始

00:14:25.420 --> 00:14:26.820
先用describe写

00:14:26.820 --> 00:14:28.480
然后把这个描述写上

00:14:28.480 --> 00:14:30.060
就是我们这一组测试

00:14:30.060 --> 00:14:31.840
是要测试这个数组旋转的

00:14:31.840 --> 00:14:34.400
然后我们在这个8里面

00:14:34.460 --> 00:14:36.120
写一个测试用力

00:14:36.120 --> 00:14:38.139
每一个8都是一个测试用力

00:14:38.139 --> 00:14:39.460
它的格式是这样的

00:14:39.460 --> 00:14:40.940
8.test.t

00:14:40.940 --> 00:14:41.780
然后一个函数

00:14:41.780 --> 00:14:42.800
接下来也是

00:14:42.800 --> 00:14:44.280
8.test.t

00:14:44.280 --> 00:14:44.780
一个函数

00:14:44.780 --> 00:14:46.120
然后8.test.t

00:14:46.120 --> 00:14:46.639
一个函数

00:14:46.639 --> 00:14:48.780
也说这个是一组测试用力

00:14:48.780 --> 00:14:49.860
然后这个呢

00:14:49.860 --> 00:14:50.980
是每个测试用力

00:14:50.980 --> 00:14:53.539
我们现在拿这个Rooter的1来为例

00:14:53.539 --> 00:14:57.080
比如说我们先写一个正常情况的旋转

00:14:57.080 --> 00:14:57.680
到底行不行

00:14:57.680 --> 00:14:59.300
我们定一个数组

00:14:59.300 --> 00:15:04.600
还是1 2 3 4 5 6 7

00:15:04.600 --> 00:15:06.879
然后key等于3

00:15:06.879 --> 00:15:07.340
对吧

00:15:07.340 --> 00:15:10.500
然后result就是这个结果是什么呢

00:15:10.500 --> 00:15:12.519
我们就旋转一下

00:15:12.519 --> 00:15:14.480
把这个数组传进去

00:15:14.480 --> 00:15:15.399
把key传进去

00:15:15.399 --> 00:15:16.340
关键次来了

00:15:16.340 --> 00:15:17.659
expect

00:15:17.659 --> 00:15:19.860
expect就是期望是什么

00:15:19.860 --> 00:15:21.600
这是我们测试的一个断言

00:15:21.600 --> 00:15:23.419
也就是我们测试看看正不正确

00:15:23.419 --> 00:15:25.139
我们期望这个数组

00:15:25.139 --> 00:15:26.980
to equal

00:15:26.980 --> 00:15:28.620
to equal的意思就是说

00:15:28.620 --> 00:15:30.039
它是相等的

00:15:30.039 --> 00:15:31.000
跟什么相等呢

00:15:31.000 --> 00:15:32.639
跟这个5 6 7

00:15:32.639 --> 00:15:35.079
1 2 3 4

00:15:35.079 --> 00:15:35.879
是相等的

00:15:35.879 --> 00:15:37.879
大家能看明白这个逻辑吧

00:15:37.879 --> 00:15:39.939
就是我先定义两个初始值

00:15:39.939 --> 00:15:41.080
然后呢

00:15:41.080 --> 00:15:43.139
我们去进行这个旋转

00:15:43.139 --> 00:15:44.600
旋转这个结果之后呢

00:15:44.600 --> 00:15:46.519
我们通过这个expect的这个方式

00:15:46.519 --> 00:15:49.019
to equal的方式来去断言

00:15:49.019 --> 00:15:50.299
或者说叫判断

00:15:50.299 --> 00:15:52.299
我们专业的说叫断言

00:15:52.299 --> 00:15:54.340
就是断言这个东西是不是相等

00:15:54.340 --> 00:15:55.799
希望它等于什么呢

00:15:55.799 --> 00:15:57.600
等于这个5 6 7 1 2 3 4

00:15:57.600 --> 00:15:58.240
对吧

00:15:58.240 --> 00:15:58.740
它如果不等

00:15:58.740 --> 00:16:00.320
就说明我们这个方法是有错误的

00:16:00.320 --> 00:16:01.399
这就是单元测试

00:16:01.399 --> 00:16:03.360
我们可以先把这个注视掉

00:16:03.360 --> 00:16:04.820
然后我们把这一个单元测试

00:16:04.820 --> 00:16:05.799
我们去运行一下

00:16:05.799 --> 00:16:06.879
怎么运行呢

00:16:06.879 --> 00:16:09.879
要不我这儿重新开一个控制台

00:16:09.879 --> 00:16:10.539
看一下吧

00:16:10.539 --> 00:16:13.460
我进入这个目录

00:16:13.460 --> 00:16:17.120
然后我运行这个mpx

00:16:17.120 --> 00:16:18.220
再打一点

00:16:18.220 --> 00:16:21.019
mpx.just

00:16:21.019 --> 00:16:27.879
然后src下面的这个arrayrotatetest.ts

00:16:27.879 --> 00:16:30.399
就是mpx.just

00:16:30.399 --> 00:16:31.840
然后把这个目录写上

00:16:31.840 --> 00:16:32.740
就可以了

00:16:32.740 --> 00:16:34.460
当然你现在这个代码目录呢

00:16:34.460 --> 00:16:35.980
就是在我们现在执行的这个目录

00:16:35.980 --> 00:16:37.399
刚才我执行那个

00:16:37.399 --> 00:16:39.220
rmdv也是在这个目录下执行的

00:16:39.220 --> 00:16:40.139
然后回车

00:16:40.139 --> 00:16:45.820
好看

00:16:45.820 --> 00:16:47.159
速度旋转

00:16:47.159 --> 00:16:48.379
然后正常情况

00:16:48.379 --> 00:16:50.860
绿色正常通过

00:16:50.860 --> 00:16:51.320
对吧

00:16:51.320 --> 00:16:53.019
所以这个就通过了

00:16:53.019 --> 00:16:54.639
我们接着写啊

00:16:54.639 --> 00:16:56.820
比如说

00:16:56.820 --> 00:16:57.840
还有一种情况

00:16:57.840 --> 00:16:59.300
我们要测试各种情况

00:16:59.300 --> 00:17:01.000
我们要注意这个代码的这个

00:17:01.000 --> 00:17:02.240
见状性

00:17:02.240 --> 00:17:02.639
对不对

00:17:02.639 --> 00:17:04.680
数组为空

00:17:04.680 --> 00:17:08.539
然后我们就把这个直接拷贝过来

00:17:08.539 --> 00:17:11.319
然后把这个数组设成空

00:17:11.319 --> 00:17:13.160
然后数组设成空

00:17:13.160 --> 00:17:15.599
或者说我们这个地方直接写个空也可以

00:17:15.599 --> 00:17:17.980
这样的话语法还会不报锁

00:17:17.980 --> 00:17:20.019
然后我们这儿也是传为个3

00:17:20.019 --> 00:17:23.039
这个时候我们拿一个空数组去弄

00:17:23.039 --> 00:17:24.839
它的结果是什么呢

00:17:24.839 --> 00:17:26.000
一定是个空数组

00:17:26.000 --> 00:17:26.199
对吧

00:17:26.199 --> 00:17:26.859
这样才正常

00:17:26.859 --> 00:17:27.939
是不是啊

00:17:27.939 --> 00:17:28.299
好

00:17:28.299 --> 00:17:32.119
我们再来一个

00:17:32.119 --> 00:17:35.319
写完之后大家就明白了哈

00:17:35.319 --> 00:17:37.480
k是负值

00:17:37.480 --> 00:17:39.200
好

00:17:39.200 --> 00:17:41.379
我们还是拿这个来说

00:17:41.379 --> 00:17:43.440
也是这个数组

00:17:43.440 --> 00:17:45.599
然后k如果等于负3

00:17:45.599 --> 00:17:48.139
它宣传出来之后是什么结果呢

00:17:48.139 --> 00:17:50.259
依然是这个5671234

00:17:50.259 --> 00:17:51.059
为什么呢

00:17:51.059 --> 00:17:53.000
因为我们这儿就了绝对值

00:17:53.000 --> 00:17:53.819
对吧

00:17:53.819 --> 00:17:55.019
它是负3也没有关系

00:17:55.019 --> 00:17:56.440
负3也没有关系

00:17:56.440 --> 00:17:57.359
这是一个情况

00:17:57.360 --> 00:18:00.520
然后还有一种情况是什么呢

00:18:00.520 --> 00:18:03.720
k不是数字

00:18:03.720 --> 00:18:05.440
当然这种情况

00:18:05.440 --> 00:18:07.120
k不是数字这种情况呢

00:18:07.120 --> 00:18:09.180
在ts下面是没有关系的

00:18:09.180 --> 00:18:11.080
因为ts下面它断言了

00:18:11.080 --> 00:18:11.960
这个k是number类型

00:18:11.960 --> 00:18:13.200
如果你不传number类型

00:18:13.200 --> 00:18:13.840
它会报错的

00:18:13.840 --> 00:18:15.020
比如说我们这个地方

00:18:15.020 --> 00:18:16.060
如果解开注释

00:18:16.060 --> 00:18:18.060
我们传一个abc

00:18:18.060 --> 00:18:19.920
大家看这个要说会报错

00:18:19.920 --> 00:18:20.220
对吧

00:18:20.220 --> 00:18:22.640
但是如果是给第三方用

00:18:22.640 --> 00:18:24.120
你指不定它传什么东西

00:18:24.120 --> 00:18:25.360
你也没法判断

00:18:25.360 --> 00:18:26.260
所以说呢

00:18:26.260 --> 00:18:26.840
我们这个地方

00:18:26.839 --> 00:18:27.679
还是要判断一下

00:18:27.679 --> 00:18:28.839
如果k不是数字

00:18:28.839 --> 00:18:30.000
那该怎么办呢

00:18:30.000 --> 00:18:31.919
那我们就再把这个拷贝出来

00:18:31.919 --> 00:18:34.159
然后如果k不是数字

00:18:34.159 --> 00:18:36.459
比如说k是一个abc

00:18:36.459 --> 00:18:37.759
当然这个地方会报错

00:18:37.759 --> 00:18:39.059
报错没有关系

00:18:39.059 --> 00:18:41.279
我们可以写一个报错的忽略

00:18:41.279 --> 00:18:42.419
就使用这个

00:18:42.419 --> 00:18:44.279
atts-ignore

00:18:44.279 --> 00:18:46.379
就可以忽略ts的检查报错

00:18:46.379 --> 00:18:48.720
那我们期望它是什么呢

00:18:48.720 --> 00:18:50.440
它的结果和这个是一样的

00:18:50.440 --> 00:18:50.720
对吧

00:18:50.720 --> 00:18:53.039
因为如果k不是数字的话

00:18:53.039 --> 00:18:55.559
我们通过我们这个代码逻辑来判断

00:18:55.559 --> 00:18:56.920
它如果一取一类似

00:18:56.920 --> 00:18:58.160
它就是个有问题的

00:18:58.160 --> 00:18:58.759
对吧

00:18:58.759 --> 00:19:00.200
或者说不是数字的

00:19:00.200 --> 00:19:00.519
然后

00:19:00.519 --> 00:19:03.759
它就会报错

00:19:03.759 --> 00:19:06.799
这个地方好像是感觉不太对

00:19:06.799 --> 00:19:07.700
我写到这儿来

00:19:07.700 --> 00:19:08.440
我让它稍微看一下

00:19:08.440 --> 00:19:13.740
我们先执行看一下吧

00:19:13.740 --> 00:19:15.420
我感觉如果k不是数字的话

00:19:15.420 --> 00:19:17.460
这个地方可能会导致一些问题

00:19:17.460 --> 00:19:18.660
我们稍微看一下

00:19:18.660 --> 00:19:20.220
哦写错了

00:19:20.220 --> 00:19:21.080
k不是数字

00:19:21.080 --> 00:19:22.380
我们直接去执行

00:19:22.380 --> 00:19:23.620
它如果有报错之后

00:19:23.620 --> 00:19:25.600
我们可以通过这个报错来去检查一下

00:19:25.600 --> 00:19:26.560
我们的代码对吧

00:19:26.560 --> 00:19:27.560
好

00:19:27.560 --> 00:19:28.000
没有问题

00:19:28.000 --> 00:19:28.360
正常

00:19:28.360 --> 00:19:29.400
也说

00:19:29.400 --> 00:19:31.040
当k不是数字的时候

00:19:31.040 --> 00:19:34.100
我们这个代码也能去准确的识别出

00:19:34.100 --> 00:19:35.340
这个异常的这个问题

00:19:35.340 --> 00:19:36.519
然后直接去

00:19:36.519 --> 00:19:37.320
在这个地方

00:19:37.320 --> 00:19:39.400
直接去返回这个return

00:19:39.400 --> 00:19:44.200
其实应该还有一种情况

00:19:44.200 --> 00:19:46.100
就是k是复制

00:19:46.100 --> 00:19:47.400
如果k是0

00:19:47.400 --> 00:19:49.600
我们再补充一下

00:19:49.600 --> 00:19:52.320
k是0

00:19:52.320 --> 00:19:58.360
我们还是把这个给它拷贝过来

00:19:58.360 --> 00:19:59.240
好

00:19:59.240 --> 00:19:59.920
不用再重新写

00:19:59.920 --> 00:20:01.840
然后如果k是0的话

00:20:01.840 --> 00:20:02.720
k是0

00:20:02.720 --> 00:20:03.640
根据我们的代码逻辑

00:20:03.640 --> 00:20:04.240
k是0的话

00:20:04.240 --> 00:20:06.540
它反馈的结果应该是和这个是完全一样的

00:20:06.540 --> 00:20:08.540
所以我们把这个拷贝过来

00:20:08.540 --> 00:20:09.720
OK

00:20:09.720 --> 00:20:11.440
然后执行

00:20:11.440 --> 00:20:17.040
好

00:20:17.039 --> 00:20:17.899
没问题

00:20:17.899 --> 00:20:18.319
对吧

00:20:18.319 --> 00:20:20.599
我们这测试的全是root的1

00:20:20.599 --> 00:20:22.899
如果我们把这个root的1改成root的2

00:20:22.899 --> 00:20:24.559
我们去试一下

00:20:24.559 --> 00:20:27.200
全改过来

00:20:27.200 --> 00:20:27.779
保存

00:20:27.779 --> 00:20:29.159
然后再执行

00:20:29.159 --> 00:20:34.039
好

00:20:34.039 --> 00:20:34.619
也没有问题

00:20:34.619 --> 00:20:35.000
对吧

00:20:35.000 --> 00:20:36.460
OK

00:20:36.460 --> 00:20:36.839
大家看

00:20:36.839 --> 00:20:38.619
我们功能测试

00:20:38.620 --> 00:20:40.340
只是简单写了这么一个例子

00:20:40.340 --> 00:20:41.000
测试没有问题

00:20:41.000 --> 00:20:43.560
但是我们单次是我们写了好多正常情况下

00:20:43.560 --> 00:20:44.980
数组为空的情况下

00:20:44.980 --> 00:20:46.060
k是复制的情况下

00:20:46.060 --> 00:20:46.920
k是零的情况下

00:20:46.920 --> 00:20:48.060
k不是数字的情况下

00:20:48.060 --> 00:20:49.260
我们都做了一个测试

00:20:49.260 --> 00:20:49.800
对不对

00:20:49.800 --> 00:20:51.680
这样的话

00:20:51.680 --> 00:20:54.820
就能保证我们的代码的这个健壮性是非常高的

00:20:54.820 --> 00:20:57.000
就是你即便是输入一些非正常

00:20:57.000 --> 00:20:57.660
非预期的情况

00:20:57.660 --> 00:20:59.300
我这个代码也可以照常去运行

00:20:59.300 --> 00:21:00.140
按照我的路径运行

00:21:00.140 --> 00:21:01.140
并没有报错

00:21:01.140 --> 00:21:03.000
并没有一个非预期的情况

00:21:03.000 --> 00:21:05.340
这个在我们开发中是非常重要的

00:21:05.340 --> 00:21:06.560
这个在面试中也是重要的

00:21:06.559 --> 00:21:08.460
特别是我们写算法题的时候

00:21:08.460 --> 00:21:09.419
大家一定要注意

00:21:09.419 --> 00:21:10.700
写算法题的时候

00:21:10.700 --> 00:21:13.119
你如果能写出单元测试

00:21:13.119 --> 00:21:15.779
这是一个非常非常非常好的一个加分项

00:21:15.779 --> 00:21:17.359
哪怕你在纸上写出

00:21:17.359 --> 00:21:19.559
哪怕你写的没有像我写的那么全

00:21:19.559 --> 00:21:21.019
能写个三个五个

00:21:21.019 --> 00:21:21.919
也没有问题

00:21:21.919 --> 00:21:23.339
至少它代表什么呢

00:21:23.339 --> 00:21:26.399
代表你有这种算法测试

00:21:26.399 --> 00:21:28.220
或者单元测试的这么一种思维

00:21:28.220 --> 00:21:31.019
这种情况是非常罕见的

00:21:31.019 --> 00:21:32.559
或者说也是非常难得的

00:21:32.559 --> 00:21:35.139
因为在我遇到的所有的候选中

00:21:35.140 --> 00:21:39.000
好像有极少人会对一个算法去写单元测试

00:21:39.000 --> 00:21:42.080
也说他们缺少这种单元测试的这种思维

00:21:42.080 --> 00:21:43.880
特别是在大厂里面

00:21:43.880 --> 00:21:45.740
大厂里面一些复杂的逻辑

00:21:45.740 --> 00:21:48.000
他们对于算法的单元测试是非常看重的

00:21:48.000 --> 00:21:49.759
如果一个算法比较复杂的话

00:21:49.759 --> 00:21:51.720
他没有这种比较极致的单元测试

00:21:51.720 --> 00:21:53.520
万一有一个人改了

00:21:53.520 --> 00:21:54.480
有些情况

00:21:54.480 --> 00:21:55.540
你通过共同测试

00:21:55.540 --> 00:21:56.080
你测试不到

00:21:56.080 --> 00:21:57.200
这是一个流坑的

00:21:57.200 --> 00:21:57.580
对不对

00:21:57.580 --> 00:22:01.000
所以说我们在写这些算法代码的时候

00:22:01.000 --> 00:22:02.620
只要能写单元测试

00:22:02.620 --> 00:22:05.500
我们就一定去写一个单元测试去试一下

00:22:05.500 --> 00:22:06.840
我们在面试的时候

00:22:06.840 --> 00:22:08.160
我们写的算法中

00:22:08.160 --> 00:22:09.380
只要能写单元测试

00:22:09.380 --> 00:22:10.840
那你就把单元测试写上

00:22:10.840 --> 00:22:11.800
让面试官看一看

00:22:11.800 --> 00:22:13.660
我相信这绝对绝对是一个

00:22:13.660 --> 00:22:15.220
非常非常好的加分项

00:22:15.220 --> 00:22:17.620
所以说我们在这花了时间写单元测试

00:22:17.620 --> 00:22:18.560
然后我们

00:22:18.560 --> 00:22:20.420
我们接下来所有的算法题

00:22:20.420 --> 00:22:22.440
我们也都会去写单元测试

00:22:22.440 --> 00:22:23.620
这个非常非常重要

00:22:23.620 --> 00:22:24.960
补充两个说明

00:22:24.960 --> 00:22:27.360
有一个是一个代码输入

00:22:27.360 --> 00:22:29.400
另外一个是没有讲清楚

00:22:29.400 --> 00:22:31.080
我们直接说一下

00:22:31.079 --> 00:22:33.039
第一个就是我当时的写单元的时候

00:22:33.039 --> 00:22:34.460
这个地方我写了一个

00:22:34.460 --> 00:22:35.919
if它等于n

00:22:35.919 --> 00:22:36.919
这个是不对的

00:22:36.919 --> 00:22:37.980
这个地方

00:22:37.980 --> 00:22:40.039
我当时还以为nib的问题

00:22:40.039 --> 00:22:41.859
其实我当时没有想到

00:22:41.859 --> 00:22:43.000
脑子里不知道想啥了

00:22:43.000 --> 00:22:45.039
应该是if它不等于n

00:22:45.039 --> 00:22:45.960
n不等于n

00:22:45.960 --> 00:22:46.919
这样就可以了

00:22:46.919 --> 00:22:47.659
这样的情况

00:22:47.659 --> 00:22:49.539
如果n是0的话也没有问题

00:22:49.539 --> 00:22:52.460
所以我们把这个直接改过来

00:22:52.460 --> 00:22:56.679
就在这儿

00:22:56.679 --> 00:22:57.679
如果在2里面用不到

00:22:57.679 --> 00:22:59.000
所以说就这一个地方

00:22:59.000 --> 00:22:59.659
我们改过来

00:22:59.660 --> 00:23:00.580
第二个问题呢

00:23:00.580 --> 00:23:04.200
就是我们在单测试里面写这个k不是数字的时候

00:23:04.200 --> 00:23:06.000
这个地方我们没有解释清楚

00:23:06.000 --> 00:23:07.820
到底为什么不是数字就可以

00:23:07.820 --> 00:23:08.900
其实是这样的

00:23:08.900 --> 00:23:09.920
如果k不是数字的话

00:23:09.920 --> 00:23:10.440
我们看一下

00:23:10.440 --> 00:23:12.140
如果k不是数字的话

00:23:12.140 --> 00:23:13.000
它这个伪达式

00:23:13.000 --> 00:23:13.820
它出来的结果

00:23:13.820 --> 00:23:14.700
它不是一个数字

00:23:14.700 --> 00:23:16.320
你看k不是数字

00:23:16.320 --> 00:23:17.900
k取余于一个长度

00:23:17.900 --> 00:23:19.279
我们可以试一下

00:23:19.279 --> 00:23:22.620
比如说mass.abs

00:23:22.620 --> 00:23:24.460
k如果不是一个数字

00:23:24.460 --> 00:23:26.380
然后它取余于一个长度

00:23:26.380 --> 00:23:27.720
长度比如说是个10

00:23:27.720 --> 00:23:29.400
出来的结果是一个not a number

00:23:29.400 --> 00:23:29.720
对吧

00:23:29.720 --> 00:23:30.759
not a number

00:23:30.759 --> 00:23:31.759
复制给了这个step

00:23:31.759 --> 00:23:33.640
那这个i小于step

00:23:33.640 --> 00:23:34.759
就not a number

00:23:34.759 --> 00:23:35.299
它有个特点

00:23:35.299 --> 00:23:36.640
就是任何计算量

00:23:36.640 --> 00:23:37.460
任何表达式

00:23:37.460 --> 00:23:38.720
跟它在一块做计算

00:23:38.720 --> 00:23:40.059
它都是返回false的

00:23:40.059 --> 00:23:40.680
所以说

00:23:40.680 --> 00:23:41.279
大家看一下

00:23:41.279 --> 00:23:42.839
如果i出字的话是值

00:23:42.839 --> 00:23:44.720
i小于一个not a number

00:23:44.720 --> 00:23:45.460
是什么结果呢

00:23:45.460 --> 00:23:48.480
就是0小于not a number

00:23:48.480 --> 00:23:49.200
它是false

00:23:49.200 --> 00:23:50.519
对吧

00:23:50.519 --> 00:23:51.880
所以如果这个地方

00:23:51.880 --> 00:23:52.600
不是数字的话

00:23:52.600 --> 00:23:53.680
那这个地方

00:23:53.680 --> 00:23:54.340
这个fal循环

00:23:54.340 --> 00:23:55.279
根本就走不下去

00:23:55.279 --> 00:23:56.579
它不会去执行

00:23:56.579 --> 00:23:58.620
所以说它就返回一个array

00:23:58.620 --> 00:24:00.180
就返回当前的结果

00:24:00.180 --> 00:24:00.779
就ok了

00:24:00.779 --> 00:24:01.460
就没有问题了

00:24:01.460 --> 00:24:02.900
所以这是那个原因

00:24:02.900 --> 00:24:04.920
这是这个地方

00:24:04.920 --> 00:24:05.960
为什么是返回结果

00:24:05.960 --> 00:24:07.420
是当前数字的一个原因

00:24:07.420 --> 00:24:08.100
是这样

00:24:08.100 --> 00:24:09.259
主要是因为它

00:24:09.259 --> 00:24:10.620
它是个not a number

00:24:10.620 --> 00:24:12.579
然后它如果是i小于not a number

00:24:12.579 --> 00:24:13.500
它本身就是false

00:24:13.500 --> 00:24:15.140
这个循环也不会去执行

00:24:15.140 --> 00:24:16.620
直接返回这个array

