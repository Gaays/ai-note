### 学习笔记：空间复杂度与时间复杂度基础

---

#### **一、空间复杂度（Space Complexity）**
1. **定义**  
   - 程序执行时所需的内存空间。
   - 前端领域通常“重时间轻空间”，因为浏览器内存充足，更关注运行速度。

2. **常见级别**  
   - **O(1)**：固定数量的空间，与输入数据量无关。  
     - 示例：定义有限个变量（如 `const a = arr[0]; const b = arr[1]`）。  
   - **O(n)**：空间与输入数据量线性相关。  
     - 示例：拷贝一个数组（如 `const newArr = [...arr]`）。  

3. **不常见级别**  
   - O(log n)、O(n²) 在前端开发中较少出现。

---

#### **二、时间复杂度（Time Complexity）**
1. **重要性**  
   - 前端性能优化的核心指标，直接影响用户体验。  
   - 算法必须避免高时间复杂度（如 O(n²)、O(2ⁿ)），否则数据量大时易崩溃。

2. **常见级别（从优到劣）**  
   - **O(1)**：常数时间（如直接访问数组元素）。  
   - **O(log n)**：对数时间（如二分查找）。  
   - **O(n)**：线性时间（如单层循环遍历数组）。  
   - **O(n log n)**：线性对数时间（如快速排序）。  
   - **O(n²)**：平方时间（如嵌套循环）。  
   - **O(2ⁿ)**：指数时间（如暴力递归斐波那契数列）。  

3. **关键案例**  
   - **React/Vue 的 VDOM Diff 算法**：  
     - 普通树对比：O(n³) → 不可用。  
     - 优化后：O(n) → 性能大幅提升。  

---

#### **三、程序员必备：复杂度敏感度**
1. **核心要求**  
   - 看到代码能快速判断其时间复杂度，形成“条件反射”。  
   - 避免写出功能正确但性能极差的代码（如 O(n²) 的嵌套循环）。

2. **学习建议**  
   - **不理解先背诵**：熟记常见复杂度对应的代码模式（如循环、递归）。  
   - **结合图表理解**：绘制函数增长曲线图（如 O(n) 线性增长 vs O(n²) 指数增长）。  

---

#### **四、前端开发的特殊性**
1. **时间 > 空间**  
   - 浏览器内存充足，优先优化时间复杂度。  
   - 后端/嵌入式需兼顾空间（内存有限）。

2. **面试重点**  
   - 时间复杂度的考核远多于空间复杂度。  

---

#### **五、总结**
1. **复杂度是算法基础**：  
   - 用大 O 表示法描述数量级（如 O(n)）。  
   - 本质是数学函数（如 O(1)=常数，O(n)=线性函数）。  

2. **优化目标**：  
   - 时间复杂度尽量控制在 O(n) 或 O(log n)，避免 O(n²) 及以上。  
   - 空间复杂度通常容忍 O(n)，但避免无意义的空间浪费。

3. **实践口诀**：  
   - “重时间、轻空间；先背诵、再理解；敏感度是关键。”  

---

**图表辅助记忆**：  
| 复杂度  | 代码表现                  | 前端适用性       |  
|---------|---------------------------|------------------|  
| O(1)    | 无循环的固定操作          | 最优             |  
| O(n)    | 单层循环                  | 可接受           |  
| O(n²)   | 嵌套循环                  | 尽量避免         |  
| O(2ⁿ)   | 递归未优化（如斐波那契）  | 绝对禁止         |  

通过反复练习和背诵，建立对复杂度的直觉判断能力！