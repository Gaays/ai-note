<!-- PROMPT_TAG: 学术 -->

### 结构化学习笔记：节流（Throttle）与防抖（Debounce）

---

#### **一、核心概念对比**
| **概念**  | **核心区别**       | **关注点** | **适用场景**               |
|-----------|--------------------|------------|---------------------------|
| **节流**  | 限制执行频率       | 过程       | 拖拽、滚动等连续触发事件  |
| **防抖**  | 限制执行次数       | 结果       | 输入框搜索、窗口调整大小  |

---

#### **二、节流（Throttle）详解**
##### **1. 定义**
- **目标**：确保函数在指定时间间隔内**最多执行一次**，避免频繁触发。
- **关键术语**：`时间间隔（delay）`、`定时器（timer）`、`排队机制`。

##### **2. 实现原理**
```javascript
function throttle(fn, delay = 100) {
  let timer = null;
  return function() {
    if (timer) return; // 已有任务排队，拒绝新请求
    timer = setTimeout(() => {
      fn.apply(this, arguments);
      timer = null;    // 执行后重置定时器
    }, delay);
  };
}
```

##### **3. 代码步骤解析**
1. **初始化定时器**：`timer`初始为`null`。
2. **检查排队状态**：若`timer`存在，直接`return`（阻止新调用）。
3. **执行函数**：通过`setTimeout`延迟执行，并在执行后清空`timer`。

##### **4. 实际应用示例**
- **场景**：拖拽（`drag`）事件中获取鼠标位置。
- **未节流问题**：每移动1像素触发一次，回调过于频繁。
- **节流效果**：每100ms触发一次，平衡流畅性与性能。
  ```javascript
  div1.addEventListener('drag', throttle(e => {
    console.log(e.offsetX, e.offsetY);
  }, 100));
  ```

---

#### **三、防抖（Debounce）对比**
##### **1. 核心差异**
- **执行时机**：
  - 节流：**首次触发后**按间隔执行（关注过程）。
  - 防抖：**最后一次触发后**延迟执行（关注结果）。
- **图示对比**：
  - 节流：输入`1-2-3-4-5` → 输出`1...3...5`（按节奏）。
  - 防抖：输入`1-2-3-4-5` → 只输出`5`（等停止后）。

---

#### **四、使用建议**
1. **选择场景**：
   - 需要实时反馈（如拖拽进度）→ **节流**。
   - 只需最终结果（如搜索框输入）→ **防抖**。
2. **生产环境**：
   - 优先使用`Lodash`的`_.throttle`和`_.debounce`，避免边界问题。
   - **注意**：面试需手写实现，但工作中避免造轮子。

---

#### **五、总结**
| **维度**   | **节流（Throttle）**          | **防抖（Debounce）**          |
|------------|-------------------------------|-------------------------------|
| **本质**   | 稀释执行频率                  | 合并多次为一次                |
| **代码**   | 定时器排队+间隔执行           | 延迟执行+重置定时器           |
| **比喻**   | 红绿灯按节奏放行              | 电梯等人齐后再关门            |

**关键记忆点**：  
- 节流是“慢性子”，防抖是“拖延症”。  
- 过程用节流，结果用防抖。