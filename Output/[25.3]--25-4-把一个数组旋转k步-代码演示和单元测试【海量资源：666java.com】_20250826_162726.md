# 学习笔记：数组旋转K步算法

## 一、问题描述
**题目**：将一个数组旋转K步

**示例**：
- 输入数组：[1,2,3,4,5,6,7]
- K=3
- 输出结果：[5,6,7,1,2,3,4]

**旋转定义**：每次旋转将数组最后一个元素移动到最前面（每次旋转1步）

## 二、两种解题思路

### 1. 方法一：pop + unshift
**核心思想**：
- 每次将数组末尾元素pop出来，然后unshift到数组最前面
- 重复K次

**步骤**：
1. 获取数组长度len
2. 处理特殊情况（空数组或K=0）
3. 计算实际移动步数：step = Math.abs(k) % len
4. 循环step次：
   - 每次pop出最后一个元素
   - unshift到数组最前面
5. 返回处理后的数组

**时间复杂度**：O(n) - 因为每次pop和unshift都是O(n)操作，循环K次

### 2. 方法二：slice + concat
**核心思想**：
- 将数组分成两部分，然后拼接

**步骤**：
1. 获取数组长度len
2. 处理特殊情况（空数组或K=0）
3. 计算实际移动步数：step = Math.abs(k) % len
4. 切片数组：
   - part1 = 数组.slice(-step) // 取出最后step个元素
   - part2 = 数组.slice(0, len-step) // 取出前面剩余元素
5. 拼接结果：part1.concat(part2)

**时间复杂度**：O(1) - slice和concat操作

## 三、代码实现与测试

### 1. 方法一实现
```typescript
function rotate1(arr: number[], k: number): number[] {
  const len = arr.length
  if (!k || len === 0) return arr
  const step = Math.abs(k) % len
  
  for (let i = 0; i < step; i++) {
    const n = arr.pop()
    if (n != null) {
      arr.unshift(n)
    }
  }
  return arr
}
```

### 2. 方法二实现
```typescript
function rotate2(arr: number[], k: number): number[] {
  const len = arr.length
  if (!k || len === 0) return arr
  const step = Math.abs(k) % len
  
  const part1 = arr.slice(-step)
  const part2 = arr.slice(0, len - step)
  return part1.concat(part2)
}
```

### 3. 单元测试
```typescript
describe('数组旋转', () => {
  it('正常情况', () => {
    const arr = [1,2,3,4,5,6,7]
    const k = 3
    const res = rotate1(arr, k)
    expect(res).toEqual([5,6,7,1,2,3,4])
  })
  
  it('数组为空', () => {
    const arr = []
    const k = 3
    const res = rotate1(arr, k)
    expect(res).toEqual([])
  })
  
  it('k是负值', () => {
    const arr = [1,2,3,4,5,6,7]
    const k = -3
    const res = rotate1(arr, k)
    expect(res).toEqual([5,6,7,1,2,3,4])
  })
  
  it('k不是数字', () => {
    const arr = [1,2,3,4,5,6,7]
    // @ts-ignore
    const k = 'abc'
    const res = rotate1(arr, k)
    expect(res).toEqual([1,2,3,4,5,6,7])
  })
  
  it('k=0', () => {
    const arr = [1,2,3,4,5,6,7]
    const k = 0
    const res = rotate1(arr, k)
    expect(res).toEqual([1,2,3,4,5,6,7])
  })
})
```

## 四、性能对比

| 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
|------|------------|------------|--------|
| pop+unshift | O(n^2) | O(1) | 原地操作但性能差 |
| slice+concat | O(1) | O(n) | 性能好但需要额外空间 |

**前端推荐**：使用slice+concat方法，因为前端更重视时间复杂度（轻空间重时间）

## 五、重要概念总结
1. **数组操作**：
   - pop(): 删除并返回最后一个元素
   - unshift(): 在数组开头添加元素
   - slice(): 返回数组的一部分
   - concat(): 连接两个或多个数组

2. **边界情况处理**：
   - 空数组
   - k=0
   - k为负值
   - k大于数组长度

3. **单元测试重要性**：
   - 确保代码健壮性
   - 覆盖各种边界情况
   - 面试中的加分项

## 六、实践建议
1. 优先考虑时间复杂度优化
2. 写出健壮的代码（处理各种边界情况）
3. 养成写单元测试的习惯
4. 面试中展示解决问题的完整思路（包括测试）