<!-- PROMPT_TAG: 自定义 -->

# 前端工程师面试教程 - 数组旋转算法解析

这段视频字幕内容主要讲解了一个前端面试中常见的算法问题：如何将一个数组旋转K步。以下是内容的整理和总结：

## 问题描述

给定一个数组（例如 `[1,2,3,4,5,6,7]`）和一个数字K（例如3），将数组旋转K步后的结果应该是 `[5,6,7,1,2,3,4]`。

旋转的定义是：每一步将数组最后一个元素移动到最前面。

## 两种解决方案

### 方法一：pop + unshift
1. 从数组末尾依次pop出元素
2. 将pop出的元素unshift到数组前面
3. 时间复杂度分析：O(n^2)，因为unshift操作需要移动所有元素

### 方法二：slice + concat
1. 使用slice(-k)获取最后k个元素
2. 使用slice(0, length-k)获取剩余元素
3. 将两部分concat连接
4. 时间复杂度分析：O(1)

## 代码实现

使用TypeScript实现了两种方法，并进行了单元测试：

```typescript
// 方法一：pop + unshift
function rotate1(arr: number[], k: number): number[] {
  const len = arr.length
  if (!k || len === 0) return arr
  const step = Math.abs(k % len)
  
  for (let i = 0; i < step; i++) {
    const n = arr.pop()
    if (n != null) {
      arr.unshift(n)
    }
  }
  return arr
}

// 方法二：slice + concat
function rotate2(arr: number[], k: number): number[] {
  const len = arr.length
  if (!k || len === 0) return arr
  const step = Math.abs(k % len)
  
  const part1 = arr.slice(-step)
  const part2 = arr.slice(0, len - step)
  return part1.concat(part2)
}
```

## 单元测试

使用Jest编写了全面的测试用例，包括：
- 正常情况
- 空数组情况
- k为负数情况
- k为0情况
- 非数字k情况

## 性能比较

方法二比方法一更优，因为：
1. 时间复杂度更低（O(1) vs O(n^2)）
2. 不修改原数组，更函数式

## 面试技巧

1. 在面试中展示单元测试思维是很好的加分项
2. 考虑各种边界条件（空数组、k为0、k为负数等）
3. 能够分析不同方法的时间/空间复杂度
4. 优先选择时间复杂度更优的方案

这个算法问题很好地考察了候选人对数组操作的熟练程度、边界条件处理能力和算法分析能力。